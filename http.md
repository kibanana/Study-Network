[link](https://www.zerocho.com/category/HTTP)

# HTTP (Hyper Text Transfer Protocol)

## Media Type ([MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types))

HTTP는 웹에서 전송되는 객체 각각에 **MIME 타입**이라는 **데이터 포맷 라벨**을 붙인다. MIME 타입은 `/`으로 
구분된 주 타입과 부 타입(`type/subtype`)으로 이루어진 문자열 라벨이다

- `text`	텍스트를 포함하는 모든 문서를 나타내며 이론상으로는 인간이 읽을 수 있어야 합니다	`text/plain, text/html, text/css, text/javascript`
- `image`	모든 종류의 이미지를 나타냅니다. (animated gif처럼) 애니메이션되는 이미지가 이미지 타입에 포함되긴 하지만, 비디오는 포함되지 않습니다.	`image/gif, image/png, image/jpeg, image/bmp, image/webp`
- `audio`	모든 종류의 오디오 파일들을 나타냅니다.	`audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav`
- `video`	모든 종류의 비디오 파일들을 나타냅니다.	`video/webm, video/ogg`
- `application`	모든 종류의 이진 데이터를 나타냅니다.	`application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml,  application/pdf`

## URI (Uniform Resource Identifier)

정보 리소스를 고유하게 식별하고 위치를 지정하며, `URL`, `URN`으로 나뉜다.

- **URL (Uniform Resource Locator, 통합 자원 지시자)**, 대부분의 URI는 URL이다
  
  특정 서버의 한 리소스에 따라 구체적인 위치를 서술한다. 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 알려준다.
  
  URL은 **Scheme(스키마, 리소스에 접근하기 위해 사용되는 프로토콜), 서버의 인터넷 주소, 웹서버의 리소스** 세 부분으로 이루어진 표준 포맷을 따른다.
  
  `https://` : Schema, Subdomain + Domain + TLD: 서버의 인터넷 주소, `/boards/1`: 웹 서버의 리소스
  
- **URN (Uniform Resource Name)**

  콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향받지 않는 유일한 이름이다. 
  위치에 영향받지 않으므로 리소스를 옮겨도 문제없이 동작하며, 리소스의 이름이 유지되면 프로토콜이 변경되어도 문제없다.

## HTTP Method

모든 HTTP 요청 메시지는 한 개의 메서드를 갖는다.

- `GET`

  서버에서 클라이언트로 지정한 리소스를 보낸다.

- `PUT`

  클라이언트에서 서버로 보낸 데이터를 지정한 리소스의 데이터로 저장한다.

- `DELETE`

  지정한 리소스를 서버에서 삭제한다.

- `POST`

  클라이언트 데이터를 서버 애플리케이션에 보낸다.
  
- `HEAD`

  지정한 리소스에 대한 응답 중 HTTP 헤더 부분만 보낸다.  

## HTTP Message

  - 시작줄
    
    요청이라면 무엇을 해야할지, 응답이라면 무엇이 일어났는지 나타낸다.
    
  - 헤더 (Header)
  
    각 헤더 필드는 `:`로 구분된 `key`, `value` 쌍으로 구성된다. 
    헤더 필드를 추가하려면 그냥 한 줄 더해서 쓰면 되고, 빈 줄로 끝난다.
  
  - 본문 (Body)
    
    요청의 본문은 웹 서버로 데이터를 실어 보내고, 응답의 본문은 클라이언트로 데이터를 반환한다. 
    
    임의의 이진 데이터를 포함할 수 있다(ex. `image, video, audio`).

## TCP/IP
`HTTP`는 Application Layer 프로토콜이다.

`TCP/IP`는 **오류 없는 데이터 전송, 데이터 순서 일치(보낸 순서대로 도착), 조각나지 않는 데이터 스트림**을 보장한다. 
또한 TCP의 Transport Layer, IP의 Network Layer의 패킷 교환 네트워크 프로토콜의 집합이다.

일단 TCP Connection(연결)이 맺어지면 클라이언트와 서버 사이의 메시지가 없어지거나, 
손상되거나 순서가 뒤바뀌어서 전달되는 일은 결코 없다.

## HTTP를 이용한 서버 리소스(ex. HTML 문서) 수신 과정
1. 서버의 URL에서 호스트명 **추출**
2. 서버의 호스트명 IP 주소로 **변환**
3. URL에 포트번호가 있다면 **추출**
4. 추출한 IP주소, 포트번호로 **웹 서버와 TCP 연결**을 맺는다
5. 클라이언트가 서버에 **HTTP 요청**을 보낸다
6. 클라이언트가 서버로부터 **HTTP 응답**을 받는다
7. **연결이 닫히면 리소스를 보여준다**

## Web 구성요소

### 프록시 (Proxy)
**클라이언트와 서버 사이에 위치한 HTTP 중계자**로, 해당 위치에서 클라이언트의 모든 HTTP 요청을 서버에 전달하며 
서버의 HTTP 응답을 클라이언트에 전달한다. 주로 **보안**을 위해 사용되며 요청과 응답을 필터링한다.

### 캐시 (Cache)
**클라이언트 가까이에 자주 찾는 웹페이지를 저장해두는 HTTP 저장소**다.

웹 캐시와 캐시 프록시는 자신을 거쳐가는 문서들 중 자주 찾는 것을 저장하는 HTTP 프록시 서버다.

다음에 클라이언트가 같은 문서를 요청하면 그 캐시가 가진 사본을 받을 수 있기에 
멀리 떨어진 웹 서버에서 문서를 받는 것보다 훨씬 빠르게 문서를 다운받을 수 있다.

### 게이트웨이 (Gateway)
**다른 서버들의 중개자로서 동작하는 특별한 서버**로, **주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용**된다. 
게이트웨이는 자신이 리소스를 갖는 보통의 서버인 것처럼 요청을 다루기때문에 
클라이언트는 자신이 게이트웨이와 통신하고 있음을 알지 못한다.

### 터널 (Tunnel)
단순히 **HTTP 통신을 전달하기만 하는 특별한 프록시**로, 
주로 **비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송하기 위해 사용**된다.

`SSL`에 이용된다. **HTTP/SSL 터널은 HTTP 요청을 받아서 목적지의 주소와 포트로 연결(Connection)을 맺고, 
이후에 암호화된 SSL 트래픽을 HTTP 채널을 통해 목적지 서버로 전송할 수 있게 된다.**

---

URL의 구성요소 중 **Scheme는 웹 클라이언트가 서버 리소스에 어떻게 접근하는지 알려주고,** 
**서버의 위치는 클라이언트 리소스가 어디에 호스팅되어있는지** 알려준다. 
**리소스의 경로는 서버에 존재하는 로컬 리소스들 중 요청받은 리소스**가 무엇인지 알려준다.

## URL Scheme 문법

`<scheme>://<user-name>:<password>@<host-name>:<port>/<path>;<parameter>?<query>#<fragment>`

- 스키마 (Scheme = Protocol)

  알파벳으로 시작하고, **대소문자를 구별하지 않는다.**

- 사용자명, 비밀번호

  리소스 접근을 위한 사용자명과 비밀번호로, 보통 `FTP` 이용시 많이 사용한다.
 
- 호스트

  리소스를 호스팅하는 서버의 호스트명 혹은 IP 주소

- 포트

  서버가 열어놓은 네트워크 포트로, HTTP는 내부적으로 TCP 프로토콜을 사용하기 때문에 **TCP 80 포트**를 사용한다.  
  ex) `https://www.google.com:443`

- 경로

  해당 리소스의 경로

- 파라미터

  **URL을 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요하다.**  
  이것이 없으면 서버는 해당 요청을 잘못 처리하거나 처리하지 않는다.  
  URL의 파라미터 컴포넌트는 **애플리케이션이 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 받는 데에 사용**한다.

- 질의 문자열

  `key=value` 형태로 **애플리케이션에 파라미터를 전달한다.** `?`로 시작하고 `&`로 각 질의할 파라미터를 구분한다.

- 프래그먼트

  **리소스 내의 특정 부분을 가리키는 컴포넌트**다. HTTP 서버는 객체 일부가 아닌, 전체만을 다루기 때문에 
  **클라이언트는 서버에 프래그먼트를 전달하지 않는다.** 
  브라우저가 서버로부터 전체 리소스를 내려받고 프래그먼트를 사용해서 리소스의 일부를 보여준다.

## 단축 URL
### 절대 URL (Absolute URL)
리소스에 접근하는 데에 필요한 모든 정보를 가진다.

### 상대 URL (Relative URL)
모든 정보를 가지고있지 않고, 리소스에 접근하기 위한 모든 정보를 얻기 위해 기저(base) URL이라는, 다른 URL을 사용해야 한다.

### 기저 URL (Base URL)
상대 URL의 기준이 된다.

**기저 URL 취득 방법**
- 리소스에서 명시적으로 제공

  HTML 문서 안에서 `<BASE>` 태그로 기저 URL을 지정한다.
  
- 리소스를 포함하는 기저 URL

  리소스의 URL을 기저 URL로 사용할 수 있다.
  
- 기저 URL이 없는 경우

  불완전하거나 깨진 URL일 수 있다. 또는 보통 절대 URL을 사용한다.

## URL 인코딩

URL에서 사용할 수 있는 문자의 한계를 넘으려 인코딩 방식이 고안되었으며, 안전하지 않는 문자를 
**`%`로 시작해서 ASCII 코드로 표현되는 두 개의 16진수 숫자로 이루어진 이스케이프 문자로 변환하는 것**이다. 

ex) `document name.html` => `http://logical-code.tistory.com/document%20name.html`

하지만 몇몇 문자열은 URL에서 예약어로 쓰이기때문에 이스케이스 문자로 변환할 필요가 있다.

- `%` : 인코딩된 문자에 사용할 이스케이프 토큰으로서 선점
- `/` : 경로 컴포넌트 내 경로 세그먼트 나누려 선점
- `.` : 경로 컴포넌트 선점
- `..` : 경로 컴포넌트 선점
- `#` : 프래그먼트의 구획 문자로 선점
- `?` : 질의 문자열의 구획 문자로 선점
- `;` : 파라미터의 구획 문자로 선점
- `:` : 스키마, 사용자 이름/비밀번호, 호스트/포트 구획 문자로서 선점
- `$, +` : 선점
- `@, &, =` : 특정 스키마에서 특별한 의미가 있으므로 선점
- `{} | ~ []` : 게이트웨이와 같은 여러 전송 대리자(agent)가 불안전하게 다루므로 제한
- `<> "` : 안전하지 않음
- `0x00-0x1F, 0x7F` : 제한
- `> 0x7F` : 제한

---

## HTTP 커넥션 관리

HTTP가 속한 Application Layer는 TCP가 속한 Transport Layer 
바로 위의 계층이기 때문에 HTTP 트랜잭션의 성능은 TCP 성능의 영향을 받는다.

### HTTP 트랜잭션 처리 과정
1. DNS 찾기
2. 연결
3. 요청
4. 처리
5. 응답
6. 종료

4번 처리 과정이 다른 부분에 비해 상당히 짧은 편이기때문에 
클라이언트와 서버가 복잡하거나 많은 데이터를 다루지 않는 이상 
**대부분의 HTTP 지연은 TCP 네트워크 지연에 의해 발생한다.**

### HTTP 트랜잭션 지연 원인

만약 URI에 기술된 호스트에 방문한 적이 없으면(캐시가 없으므로) 
DNS 인프라를 사용해서 **호스트명을 IP로 변환**하는 데에 시간이 소요된다.

새로운 TCP 커넥션마다 **커넥션 설정 시간**이 필요하기 때문에 수백 개의 트랜잭션 발생 시 소요 시간이 증가한다.

요청 메시지가 인터넷을 통해 **전달**되고 서버에 의해서 **처리**되는 시간

웹 서버가 **HTTP 응답을 보내는 시간**

### HTTP 구현 중 걸리는 일반적인 TCP 지연

- TCP 커넥션 **핸드셰이크** 설정
- TCP **`SLOW-START`(느린 시작)** 으로 인터넷 혼잡 제어
- 데이터를 한 데 모아서 **한 번에 전송하기 위한 네이글 알고리즘(`NAGLE-ALGORITHM`)**
- TCP **편승 확인 응답(`PIGGYBACK ACKNOWLEDGMENT`)** 을 위한 **확인 응답 지연 알고리즘**
- **`TIME_WAIT` 지연**과 **포트 고갈**

### TCP 커넥션 핸드셰이크 지연

어떤 데이터를 전송하는 새로운 TCP 커넥션을 열면 TCP 소프트웨어는 커넥션을 맺기 위한 조건을 충족하기 위해 
연속으로 IP 패킷을 교환한다.  
=> **작은 크기의 데이터 전송에 커넥션이 사용된다면 이런 패킷 교환때문에 HTTP 성능을 크게 저하될 수 있다**

1. Client는 새로운 TCP 커넥션 생성을 위해 작은 TCP 패킷을 Server에 보낸다.

    `SYN` 플래그로 해당 요청이 커넥션 생성 요청임을 알린다

2. Server가 그 커넥션을 받으면 커넥션 요청이 받아들여졌음을 의미하는 `SYN`, `ACK` 플래그를 포함한 TCP 패킷을 Client에 보낸다.
3. Client에서 커넥션이 잘 맺어졌음을 알리는 `ACK` 플래그를 포함한 신호를 보낸다.

  **크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP 구성에 소모한다**

### 확인 응답 지연

인터넷 자체가 패킷 전송을 완벽하게 보장하지 않기 때문에 
TCP는 성공적인 데이터 전송을 보장하기 위해 자체적인 확인 체계를 가진다. 
각 TCP 세그먼트는 순번과 데이터 무결성을 체크하는 `Checksum`을 가진다. 
각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인 응답 패킷을 송신자에게 반환한다. 
만약 송신자가 특정 시간 내에 확인 응답 패킷을 받지 못하면 패킷이 파기 or 오류 발생한 것으로 판단하고 데이터를 다시 전송한다.

- 확인 응답은 **크기가 작기 때문에 TCP는 같은 방향으로 송출되는 데이터 패킷에 확인 응답을 편승(PIGGYBACK)시킨다.**
- 확인 응답이 **같은 방향으로 가는 데이터 패킷에 편승하는 경우를 늘리기 위해 많은 TCP 스택은 확인 응답 지연 알고리즘을 구현한다.**

> 확인 응답 지연 알고리즘이란?  
  송출할 확인 응답을 특정 시간동안 버퍼에 저장해두고, 확인 응답을 편승시키기 위한 송출 데이터 패킷을 찾는다. 
  만약 찾지 못하면 별도 패킷을 만들어서 전송한다.
  
요청과 응답. 이 두 가지 형식만의 HTTP 동작 방식은 확인 응답이 송출 데이터 패킷에 편승할 기회를 감소시킨다. 
따라서 확인 응답 지연 알고리즘으로 인한 지연이 자주 발생한다. 
이를 막기 위해 (운영체제에 따라 다르지만) 확인 응답 지연 관련 기능을 수정하거나 비활성화할 수 있다.

### TCP `SLOW-START`(느린 시작)
TCP 커넥션은 시간이 지나며 자체적으로 **튜닝**된다. **처음에는 커넥션 최대 속도를 제한**하고, 
**데이터가 성공적으로 전송되면서 속도 제한을 높여간다.** TCP 느린 시작은 TCP가 한 번에 전송할 수 있는 패킷 수를 제한한다.

1. 송신자는 패킷이 성공적으로 전달될 때, 추가로 패킷 2개를 더 전송할 수 있는 권한을 얻는다.
2. HTTP 트랜잭션에 전송할 데이터의 양이 많으면 모든 패킷을 한 번에 전송할 수 없고,  
    대신 한 개의 패킷만 전송하고 확인 응답을 기다려야 한다.
3. 확인 응답을 받으면 2개의 패킷을 보낼 수 있으며, 그 패킷 각각에 확인 응답을 받으면 패킷 4개를 보낼 수 있다.

### 네이글 알고리즘(`NAGLE-ALGORITHM`)과 `TCP_NODELAY`
네트워크 효율을 위해 패킷을 전송하기 위한 많은 양의 TCP 데이터를 **한 개의 덩어리로 합친다.** 
네이글 알고리즘은 **세그먼트가 최대 크기가 되지 않으면 전송하지 않는다.** 
다만 다른 **모든 패킷이 확인 응답을 받았을 경우엔** 최대 크기보다 작은 패킷의 **전송을 허락**한다.

#### 네이글 알고리즘이 HTTP 성능에 발생시키는 문제
1. 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에 안생길지도 모르는 추가적인 데이터를 기다리며 지연된다.
2. 확인 응답 지연과 함께 쓰일 경우 형편없이 동작한다.  
    => 네이글 알고리즘으로 확인 응답이 도착할때까지 데이터 전송 멈춤, 확인 응답 지연 알고리즘은 확인 응답을 100~200ms 지연시킨다.

















