

# HTTP (Hyper Text Transfer Protocol)

[link](https://www.zerocho.com/category/HTTP)

## HTTP란?
Hyper Text Transfer Protocol의 약자로, 인터넷에서 데이터를 주고받을 수 있는 프로토콜(= 규칙)이다. 
모든 프로그램이 이 규칙을 지키도록 개발하면 서로 정보를 교환할 수 있게 된다.

주로 웹 개발자가 HTTP를 사용하며, HTTP는 에러를 해결하는 데에도 중요한다.

![image](https://user-images.githubusercontent.com/37951612/78293889-4bf8d700-7564-11ea-83be-b86da376cc08.png)

> 서버의 역할: 요청에 대한 응답을 보내주는 것

### 요청 (Request)
클라이언트가 요청한 정보를 받은 서버는 클라이언트가 원하는 것을 파악하고, 응답에 대한 정보를 담아서 클라이언트에 보낸다. 이런 정보가 담긴 메시지를 **HTTP 메시지**라고 한다. **HTTP 메시지는 시작줄, 헤더, 본문으로 구성된다.**

```
GET https://www.naver.com HTTP/1.1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...
Upgrade-Insecure-Requests: 1
```

- 시작줄: 첫 줄. `GET`- HTTP **메서드(Method)**, `https://www.naver.com`- **주소**, `HTTP/1.1`- **HTTP 버전**
- 헤더: 두 번째 줄부터 시작. 요청에 대한 정보를 담고 있으며 헤더의 종류는 매우 많다.
- 본문: 헤더에서 한 줄 띄고 본문 시작. 요청을 할 때 필요한 데이터를 담는 부분이다. HTTP Method가 `GET`, `DELETE`일 경우 해당 값은 비어있다.

### 응답 (Response)

```
HTTP/1.1 200 OK
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 35653
Content-Type: text/html;

<!DOCTYPE html><html><head> ···
```

요청과 마찬가지로 **HTTP 메시지는 시작줄, 헤더, 본문으로 구성된다.**

- 시작줄: 첫줄. `HTTP/1.1`- HTTP 버전, `200`- HTTP 상태코드(Status Code), `OK`- HTTP 상태메시지
- 헤더: 두번째 줄부터 시작. 응답에 대한 정보를 담고 있다.
- 본문: 응답에는 보통 본문이 있으며, 요청한 데이터가 여기에 담긴다.

## HTTP 메서드(Method)

`GET, POST, PUT, PATCH, DELETE`를 주로 사용하며, `OPTIONS, HEAD, CONNECT, TRACE` 라는 HTTP 메서드도 있다.

해당 URL에 대한 어떤 동작을 하려고 할 때 알맞은 HTTP 메서드를 사용하여 요청하면 된다. 
하지만 요청만 보낸다고 모든 요청이 정상적으로 처리되는 것은 아니고, 서버가 요청을 검증해서 유효하면 실행된다.

`GET, DELETE`를 제외한 `POST, PUT, PATCH`는 요청을 보낼 때 본문을 같이 보낼 수 있다. 
사실 `GET, DELETE`에도 본문을 넣어 보내는 것이 가능하지만 이에 대한 처리 정의가 없다(서버가 본문을 무시하는 것 권장).

만약 요청에 필요한 데이터를 본문에 담는다면 서버는 이 본문을 받아서 파싱(해석)한 후 사용하게 된다. 
만약 GET에도 꼭 데이터를 담아 보내고 싶다면 URL 뒤에 `?<key>=<value>` 쿼리스트링 형식으로 데이터를 보내면 된다.

- HEAD

  **GET** 요청에서 헤더만 가져올 때 사용된다.

- `OPTIONS`

  서버가 어떤 메서드를 지원하는지 알아볼 때 사용된다.
  
  요청 URL에 따라 `GET, HEAD`가 올 수도, `GET, HEAD, POST`가 올 수도 있다. 해당 URL에서 지원하는 메서드를 응답한다.
  
  CORS 상황에서는 다른 도메인 서버에 먼저 OPTIONS 요청을 날리고 그 서버가 요청을 허용하면 실제 요청을 날린다. 
  `OPIONS` 요청은 서버에 실제 요청을 보내기 전 서버를 테스트하는 용도라고 생각할 수 있다.

- TRACE

  ex) 핑퐁 테스트

- CONNECT

  ex) 양방향 통신


## HTTP 공통 & 요청 헤더

### 공통 헤더 (요청, 응답에 사용)

- `Date`

  HTTP 메시지가 자동으로 만든 시각

- `Connection`

  기본값은 `keep-alive`로, 사실상 아무 의미도 없다. HTTP/2 에서는 아예 사라졌다.

- `Cache-Control`: ↓
- **`Content-Length`**

  요청과 응답 메시지의 본문 크기를 byte 단위로 표시해준다. 메시지 크기에 따라 자동으로 만들어진다.

- `Content-Type`

  `Content-Type: text/html; charset=utf-8` => 현재 메시지 내용이 `text/html` 타입이며, `utf-8` 문자열이다
  
  Content의 타입, 문자열 인코딩을 명시할 수 있다. **`Accept, Accept-Charset` 헤더와 대응**된다.

- `Content-Language`

  사용자 언어를 뜻한다. 
  
  ex) 한국인에게 영어를 가르치는 사이트라면, 페이지 언어는 영어더라도 `Content-Language`가 `ko-KR`일 수 있다.

- `Content-Encoding`

  `Content-Encoding: gzip, deflate`
  
  Content가 압축된 방식을 뜻한다. 응답 컨텐츠를 해당 알고리즘들로 압축해서 보내면 브라우저가 해제해서 사용한다.
  
  Content 용량이 줄어들기 때문에 요청이나 응답 전송 속도도 빨라지고, 데이터 소모량이 줄어든다.
  
### 요청 헤더

- `Host`

  `Host: www.naver.com`

  서버의 도메인 네임(포트 포함). 반드시 한 개가 존재해야 한다.

- **`User-Agent`**

  현재 사용자가 어떤 클라이언트를 이용하여 요청했는지에 대한 정보(OS, Browser)를 볼 수 있다.
  
  
  헤더는 변경할 수 있기 때문에 완전히 신뢰할 수는 없지만, 대부분의 사람이 User-Agent 헤더를 조작하지 않고 그대로 보내기 때문에 이를 활용하여 접속자 통계 등을 내곤 한다. 또는 사용할 수 있는 브라우저가 정해진 경우 'IE는 지원하지 않습니다. Chrome으로 접속해주세요' 같은 메시지를 보내기도 한다.

- **`Accept`**

  요청을 보낼 때 서버에 특정 타입(MIME)의 데이터를 보내줬다고 명시하는 역할을 한다.
  
  `Accept: text/html` => HTML 형식인 응답을 처리하겠다는 뜻이다
  
  `,`(콤마, comma)를 이용하여 여러 타입을 동시에 명시할 수 있고, 
  `*`(와일드카드, wildcard)를 `text/*`처럼 이용하여 'text 이기만 하면 subtype은 상관없어'라고 알릴 수도 있다.
  
  요청 헤더의 `Accept` 시리즈는 공통 헤더의 `Content` 시리즈와 대응된다.  
  ex) `Accept-Encoding`, `Accept-Charset`, `Accept-Language`  
  `Accept` 헤더에 뭘 적어야할지 모르겠다면 그냥 `*`를 적거나, 브라우저가 알아서 설정하는 `Accept`를 사용하면 된다.

- `Authorization`
  
  인증 토큰을 서버로 보낼 때 사용하는 헤더로, API 요청 등을 할 때 인증을 위한 토큰을 담기 위해 사용한다.
  
  `Authorization: Bearer <token>` 등의 형태로 먼저 토큰의 종류(ex. Basic, Bearer)를 알리고 실제 토큰을 적는다.
  
- `Origin`

  POST 같은 요청에서 요청이 어느 주소에서 시작되었는지를 나타낸다. 만약 요청을 보낸 주소, 받는 주소가 다르면 **CORS** 문제가 발생하기도 한다.

- `Referer`

  이 페이지 이전의 주소가 담겨있다. 주로 애널리스틱(분석) 용도로 사용한다. 사실 Referrer의 오타다.


## HTTP 응답 헤더

### `Access-Control-Allow-Origin`
프론트엔드 개발자가 작성한 요청을 보내는 프론트 주소와 그 요청을 받는 백엔드 주소가 다르면 **CORS(Protocol, Sub Domain, Domain, Port 중 하나만 달라도)** 에러가 발생한다. 이 때 서버에서 응답 메시지 헤더에 적절한 값을 명시해주어야 한다. 일일이 지정하기 귀찮다면 `*`(와일드카드)를 사용할 수 있지만, 그만큼 보안이 취약해진다.

**CORS** 요청 시에는 미리 `OPTIONS`로 서버가 CORS를 허용하는지 물어본다. 이 때 아래 헤더들도 적절히 소통한다. `~Request~` 헤더들은 `~Allow~` 헤더에 대응된다. 두 헤더가 대응되면 CORS 요청&응답이 이루어지는 것이다.

### `Access-Control-Request-Method`, `Access-Control-Request-Headers`
요청 헤더에서 사용된다

### `Access-Control-Allow-Methods`, `Access-Control-Allow-Headers`
응답 헤더에서 사용된다

### `Allow`
`Access-Control-Allow-Methods`와 비슷하지만 CORS 요청 이외에도 적용된다. 이 헤더에 작성된 규칙을 위반하면 `405 Method Not Allowed` 에러를 응답한다.

만약 동일 주소에 대해 `GET` 요청은 되고 `POST` 요청은 안된다면 에러를 응답하면서 헤더로 `Allow: GET`을 보내면 된다.

### `Content-Disposition`
응답 본문을 브라우저가 어떻게 표시해야할지 알려준다.
- `inline`: 웹페이지 화면에 표시
- `attachment`: 다운로드 되기를 원하는 파일에 설정. `; filename='clean.csv'` 형태로 파일명까지 지정할 수 있다.

### `Location`
HTTP 응답 메시지의 상태코드가 `201`이나 `300번대`일 때, 어느 페이지로 이동해야하는지 알려주는 헤더다. `Location` 헤더의 값으로 리다이렉트한다.

### [`Content-Security-Policy`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
외부 파일을 불러오는 경우, 차단할 소스와 불러올 소스를 명시할 수 있는 헤더다.  
만약 악성코드가 담긴 파일을 불러온다면? XSS 공격 등을 당할 수도 있다.

```
Content-Security-Policy: default-src 'self'
Content-Security-Policy: default-src https:
Content-Security-Policy: default-src 'none'
```

- default-src : 모든 외부 소스에 적용되며, 각각 따로 지정할 수도 있다. 
- self : 자신의 도메인 내의 파일만 가져올 수 있다.
- https : HTTPS를 통해서만 파일을 가져올 수 있다.
- none : 파일을 가져올 수 없다.

`font-src, script-src, img-src, style-src, object-src` 등이 있고, 소스 옵션으로는 도메인이나, `https:`, `unsafe-inline`(인라인 태그 허용), `unsafe-eval`(eval 함수 허용) 등이 있습니다.

## HTTP 쿠키 & 캐시 헤더


## HTTP X 헤더


---

## Media Type ([MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types))

HTTP는 웹에서 전송되는 객체 각각에 **MIME 타입**이라는 **데이터 포맷 라벨**을 붙인다. MIME 타입은 `/`으로 
구분된 주 타입과 부 타입(`type/subtype`)으로 이루어진 문자열 라벨이다

- `text`	텍스트를 포함하는 모든 문서를 나타내며 이론상으로는 인간이 읽을 수 있어야 합니다	`text/plain, text/html, text/css, text/javascript`
- `image`	모든 종류의 이미지를 나타냅니다. (animated gif처럼) 애니메이션되는 이미지가 이미지 타입에 포함되긴 하지만, 비디오는 포함되지 않습니다.	`image/gif, image/png, image/jpeg, image/bmp, image/webp`
- `audio`	모든 종류의 오디오 파일들을 나타냅니다.	`audio/midi, audio/mpeg, audio/webm, audio/ogg, audio/wav`
- `video`	모든 종류의 비디오 파일들을 나타냅니다.	`video/webm, video/ogg`
- `application`	모든 종류의 이진 데이터를 나타냅니다.	`application/octet-stream, application/pkcs12, application/vnd.mspowerpoint, application/xhtml+xml, application/xml,  application/pdf`

## URI (Uniform Resource Identifier)

정보 리소스를 고유하게 식별하고 위치를 지정하며, `URL`, `URN`으로 나뉜다.

- **URL (Uniform Resource Locator, 통합 자원 지시자)**, 대부분의 URI는 URL이다
  
  특정 서버의 한 리소스에 따라 구체적인 위치를 서술한다. 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 알려준다.
  
  URL은 **Scheme(스키마, 리소스에 접근하기 위해 사용되는 프로토콜), 서버의 인터넷 주소, 웹서버의 리소스** 세 부분으로 이루어진 표준 포맷을 따른다.
  
  `https://` : Schema, Subdomain + Domain + TLD: 서버의 인터넷 주소, `/boards/1`: 웹 서버의 리소스
  
- **URN (Uniform Resource Name)**

  콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향받지 않는 유일한 이름이다. 
  위치에 영향받지 않으므로 리소스를 옮겨도 문제없이 동작하며, 리소스의 이름이 유지되면 프로토콜이 변경되어도 문제없다.

## HTTP Method

모든 HTTP 요청 메시지는 한 개의 메서드를 갖는다.

- `GET`

  서버에서 클라이언트로 지정한 리소스를 보낸다.

- `PUT`

  클라이언트에서 서버로 보낸 데이터를 지정한 리소스의 데이터로 저장한다.

- `DELETE`

  지정한 리소스를 서버에서 삭제한다.

- `POST`

  클라이언트 데이터를 서버 애플리케이션에 보낸다.
  
- `HEAD`

  지정한 리소스에 대한 응답 중 HTTP 헤더 부분만 보낸다.  

## HTTP Message

  - 시작줄
    
    요청이라면 무엇을 해야할지, 응답이라면 무엇이 일어났는지 나타낸다.
    
  - 헤더 (Header)
  
    각 헤더 필드는 `:`로 구분된 `key`, `value` 쌍으로 구성된다. 
    헤더 필드를 추가하려면 그냥 한 줄 더해서 쓰면 되고, 빈 줄로 끝난다.
  
  - 본문 (Body)
    
    요청의 본문은 웹 서버로 데이터를 실어 보내고, 응답의 본문은 클라이언트로 데이터를 반환한다. 
    
    임의의 이진 데이터를 포함할 수 있다(ex. `image, video, audio`).

## TCP/IP
`HTTP`는 Application Layer 프로토콜이다.

`TCP/IP`는 **오류 없는 데이터 전송, 데이터 순서 일치(보낸 순서대로 도착), 조각나지 않는 데이터 스트림**을 보장한다. 
또한 TCP의 Transport Layer, IP의 Network Layer의 패킷 교환 네트워크 프로토콜의 집합이다.

일단 TCP Connection(연결)이 맺어지면 클라이언트와 서버 사이의 메시지가 없어지거나, 
손상되거나 순서가 뒤바뀌어서 전달되는 일은 결코 없다.

## HTTP를 이용한 서버 리소스(ex. HTML 문서) 수신 과정
1. 서버의 URL에서 호스트명 **추출**
2. 서버의 호스트명 IP 주소로 **변환**
3. URL에 포트번호가 있다면 **추출**
4. 추출한 IP주소, 포트번호로 **웹 서버와 TCP 연결**을 맺는다
5. 클라이언트가 서버에 **HTTP 요청**을 보낸다
6. 클라이언트가 서버로부터 **HTTP 응답**을 받는다
7. **연결이 닫히면 리소스를 보여준다**

## Web 구성요소

### 프록시 (Proxy)
**클라이언트와 서버 사이에 위치한 HTTP 중계자**로, 해당 위치에서 클라이언트의 모든 HTTP 요청을 서버에 전달하며 
서버의 HTTP 응답을 클라이언트에 전달한다. 주로 **보안**을 위해 사용되며 요청과 응답을 필터링한다.

### 캐시 (Cache)
**클라이언트 가까이에 자주 찾는 웹페이지를 저장해두는 HTTP 저장소**다.

웹 캐시와 캐시 프록시는 자신을 거쳐가는 문서들 중 자주 찾는 것을 저장하는 HTTP 프록시 서버다.

다음에 클라이언트가 같은 문서를 요청하면 그 캐시가 가진 사본을 받을 수 있기에 
멀리 떨어진 웹 서버에서 문서를 받는 것보다 훨씬 빠르게 문서를 다운받을 수 있다.

### 게이트웨이 (Gateway)
**다른 서버들의 중개자로서 동작하는 특별한 서버**로, **주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용**된다. 
게이트웨이는 자신이 리소스를 갖는 보통의 서버인 것처럼 요청을 다루기때문에 
클라이언트는 자신이 게이트웨이와 통신하고 있음을 알지 못한다.

### 터널 (Tunnel)
단순히 **HTTP 통신을 전달하기만 하는 특별한 프록시**로, 
주로 **비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송하기 위해 사용**된다.

`SSL`에 이용된다. **HTTP/SSL 터널은 HTTP 요청을 받아서 목적지의 주소와 포트로 연결(Connection)을 맺고, 
이후에 암호화된 SSL 트래픽을 HTTP 채널을 통해 목적지 서버로 전송할 수 있게 된다.**

---

URL의 구성요소 중 **Scheme는 웹 클라이언트가 서버 리소스에 어떻게 접근하는지 알려주고,** 
**서버의 위치는 클라이언트 리소스가 어디에 호스팅되어있는지** 알려준다. 
**리소스의 경로는 서버에 존재하는 로컬 리소스들 중 요청받은 리소스**가 무엇인지 알려준다.

## URL Scheme 문법

`<scheme>://<user-name>:<password>@<host-name>:<port>/<path>;<parameter>?<query>#<fragment>`

- 스키마 (Scheme = Protocol)

  알파벳으로 시작하고, **대소문자를 구별하지 않는다.**

- 사용자명, 비밀번호

  리소스 접근을 위한 사용자명과 비밀번호로, 보통 `FTP` 이용시 많이 사용한다.
 
- 호스트

  리소스를 호스팅하는 서버의 호스트명 혹은 IP 주소

- 포트

  서버가 열어놓은 네트워크 포트로, HTTP는 내부적으로 TCP 프로토콜을 사용하기 때문에 **TCP 80 포트**를 사용한다.  
  ex) `https://www.google.com:443`

- 경로

  해당 리소스의 경로

- 파라미터

  **URL을 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요하다.**  
  이것이 없으면 서버는 해당 요청을 잘못 처리하거나 처리하지 않는다.  
  URL의 파라미터 컴포넌트는 **애플리케이션이 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 받는 데에 사용**한다.

- 질의 문자열

  `key=value` 형태로 **애플리케이션에 파라미터를 전달한다.** `?`로 시작하고 `&`로 각 질의할 파라미터를 구분한다.

- 프래그먼트

  **리소스 내의 특정 부분을 가리키는 컴포넌트**다. HTTP 서버는 객체 일부가 아닌, 전체만을 다루기 때문에 
  **클라이언트는 서버에 프래그먼트를 전달하지 않는다.** 
  브라우저가 서버로부터 전체 리소스를 내려받고 프래그먼트를 사용해서 리소스의 일부를 보여준다.

## 단축 URL
### 절대 URL (Absolute URL)
리소스에 접근하는 데에 필요한 모든 정보를 가진다.

### 상대 URL (Relative URL)
모든 정보를 가지고있지 않고, 리소스에 접근하기 위한 모든 정보를 얻기 위해 기저(base) URL이라는, 다른 URL을 사용해야 한다.

### 기저 URL (Base URL)
상대 URL의 기준이 된다.

**기저 URL 취득 방법**
- 리소스에서 명시적으로 제공

  HTML 문서 안에서 `<BASE>` 태그로 기저 URL을 지정한다.
  
- 리소스를 포함하는 기저 URL

  리소스의 URL을 기저 URL로 사용할 수 있다.
  
- 기저 URL이 없는 경우

  불완전하거나 깨진 URL일 수 있다. 또는 보통 절대 URL을 사용한다.

## URL 인코딩

URL에서 사용할 수 있는 문자의 한계를 넘으려 인코딩 방식이 고안되었으며, 안전하지 않는 문자를 
**`%`로 시작해서 ASCII 코드로 표현되는 두 개의 16진수 숫자로 이루어진 이스케이프 문자로 변환하는 것**이다. 

ex) `document name.html` => `http://logical-code.tistory.com/document%20name.html`

하지만 몇몇 문자열은 URL에서 예약어로 쓰이기때문에 이스케이스 문자로 변환할 필요가 있다.

- `%` : 인코딩된 문자에 사용할 이스케이프 토큰으로서 선점
- `/` : 경로 컴포넌트 내 경로 세그먼트 나누려 선점
- `.` : 경로 컴포넌트 선점
- `..` : 경로 컴포넌트 선점
- `#` : 프래그먼트의 구획 문자로 선점
- `?` : 질의 문자열의 구획 문자로 선점
- `;` : 파라미터의 구획 문자로 선점
- `:` : 스키마, 사용자 이름/비밀번호, 호스트/포트 구획 문자로서 선점
- `$, +` : 선점
- `@, &, =` : 특정 스키마에서 특별한 의미가 있으므로 선점
- `{} | ~ []` : 게이트웨이와 같은 여러 전송 대리자(agent)가 불안전하게 다루므로 제한
- `<> "` : 안전하지 않음
- `0x00-0x1F, 0x7F` : 제한
- `> 0x7F` : 제한

---

## HTTP 커넥션 관리

HTTP가 속한 Application Layer는 TCP가 속한 Transport Layer 
바로 위의 계층이기 때문에 HTTP 트랜잭션의 성능은 TCP 성능의 영향을 받는다.

### HTTP 트랜잭션 처리 과정
1. DNS 찾기
2. 연결
3. 요청
4. 처리
5. 응답
6. 종료

4번 처리 과정이 다른 부분에 비해 상당히 짧은 편이기때문에 
클라이언트와 서버가 복잡하거나 많은 데이터를 다루지 않는 이상 
**대부분의 HTTP 지연은 TCP 네트워크 지연에 의해 발생한다.**

### HTTP 트랜잭션 지연 원인

만약 URI에 기술된 호스트에 방문한 적이 없으면(캐시가 없으므로) 
DNS 인프라를 사용해서 **호스트명을 IP로 변환**하는 데에 시간이 소요된다.

새로운 TCP 커넥션마다 **커넥션 설정 시간**이 필요하기 때문에 수백 개의 트랜잭션 발생 시 소요 시간이 증가한다.

요청 메시지가 인터넷을 통해 **전달**되고 서버에 의해서 **처리**되는 시간

웹 서버가 **HTTP 응답을 보내는 시간**

### HTTP 구현 중 걸리는 일반적인 TCP 지연

- TCP 커넥션 **핸드셰이크** 설정
- TCP **`SLOW-START`(느린 시작)** 으로 인터넷 혼잡 제어
- 데이터를 한 데 모아서 **한 번에 전송하기 위한 네이글 알고리즘(`NAGLE-ALGORITHM`)**
- TCP **편승 확인 응답(`PIGGYBACK ACKNOWLEDGMENT`)** 을 위한 **확인 응답 지연 알고리즘**
- **`TIME_WAIT` 지연**과 **포트 고갈**

### TCP 커넥션 핸드셰이크 지연

어떤 데이터를 전송하는 새로운 TCP 커넥션을 열면 TCP 소프트웨어는 커넥션을 맺기 위한 조건을 충족하기 위해 
연속으로 IP 패킷을 교환한다.  
=> **작은 크기의 데이터 전송에 커넥션이 사용된다면 이런 패킷 교환때문에 HTTP 성능을 크게 저하될 수 있다**

1. Client는 새로운 TCP 커넥션 생성을 위해 작은 TCP 패킷을 Server에 보낸다.

    `SYN` 플래그로 해당 요청이 커넥션 생성 요청임을 알린다

2. Server가 그 커넥션을 받으면 커넥션 요청이 받아들여졌음을 의미하는 `SYN`, `ACK` 플래그를 포함한 TCP 패킷을 Client에 보낸다.
3. Client에서 커넥션이 잘 맺어졌음을 알리는 `ACK` 플래그를 포함한 신호를 보낸다.

  **크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP 구성에 소모한다**

### 확인 응답 지연

인터넷 자체가 패킷 전송을 완벽하게 보장하지 않기 때문에 
TCP는 성공적인 데이터 전송을 보장하기 위해 자체적인 확인 체계를 가진다. 
각 TCP 세그먼트는 순번과 데이터 무결성을 체크하는 `Checksum`을 가진다. 
각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인 응답 패킷을 송신자에게 반환한다. 
만약 송신자가 특정 시간 내에 확인 응답 패킷을 받지 못하면 패킷이 파기 or 오류 발생한 것으로 판단하고 데이터를 다시 전송한다.

- 확인 응답은 **크기가 작기 때문에 TCP는 같은 방향으로 송출되는 데이터 패킷에 확인 응답을 편승(PIGGYBACK)시킨다.**
- 확인 응답이 **같은 방향으로 가는 데이터 패킷에 편승하는 경우를 늘리기 위해 많은 TCP 스택은 확인 응답 지연 알고리즘을 구현한다.**

> 확인 응답 지연 알고리즘이란?  
  송출할 확인 응답을 특정 시간동안 버퍼에 저장해두고, 확인 응답을 편승시키기 위한 송출 데이터 패킷을 찾는다. 
  만약 찾지 못하면 별도 패킷을 만들어서 전송한다.
  
요청과 응답. 이 두 가지 형식만의 HTTP 동작 방식은 확인 응답이 송출 데이터 패킷에 편승할 기회를 감소시킨다. 
따라서 확인 응답 지연 알고리즘으로 인한 지연이 자주 발생한다. 
이를 막기 위해 (운영체제에 따라 다르지만) 확인 응답 지연 관련 기능을 수정하거나 비활성화할 수 있다.

### TCP `SLOW-START`(느린 시작)
TCP 커넥션은 시간이 지나며 자체적으로 **튜닝**된다. **처음에는 커넥션 최대 속도를 제한**하고, 
**데이터가 성공적으로 전송되면서 속도 제한을 높여간다.** TCP 느린 시작은 TCP가 한 번에 전송할 수 있는 패킷 수를 제한한다.

1. 송신자는 패킷이 성공적으로 전달될 때, 추가로 패킷 2개를 더 전송할 수 있는 권한을 얻는다.
2. HTTP 트랜잭션에 전송할 데이터의 양이 많으면 모든 패킷을 한 번에 전송할 수 없고,  
    대신 한 개의 패킷만 전송하고 확인 응답을 기다려야 한다.
3. 확인 응답을 받으면 2개의 패킷을 보낼 수 있으며, 그 패킷 각각에 확인 응답을 받으면 패킷 4개를 보낼 수 있다.

### 네이글 알고리즘(`NAGLE-ALGORITHM`)과 `TCP_NODELAY`
네트워크 효율을 위해 패킷을 전송하기 위한 많은 양의 TCP 데이터를 **한 개의 덩어리로 합친다.** 
네이글 알고리즘은 **세그먼트가 최대 크기가 되지 않으면 전송하지 않는다.** 
다만 다른 **모든 패킷이 확인 응답을 받았을 경우엔** 최대 크기보다 작은 패킷의 **전송을 허락**한다.

#### 네이글 알고리즘이 HTTP 성능에 발생시키는 문제
1. 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에 안생길지도 모르는 추가적인 데이터를 기다리며 지연된다.
2. 확인 응답 지연과 함께 쓰일 경우 형편없이 동작한다.  
    => 네이글 알고리즘으로 확인 응답이 도착할때까지 데이터 전송 멈춤, 확인 응답 지연 알고리즘은 확인 응답을 100~200ms 지연시킨다.

















