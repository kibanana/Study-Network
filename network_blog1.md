# [[link](https://real-dongsoo7.tistory.com/category/Computer%20Network)]

# OSI 7 Layer Model
## OSI 7 Layer Model

> 국제 표준화 기구가 발표했다. 통신이 일어나는 과정을 7단계로 구분하여 한눈에 볼 수 있으며,  
컴퓨터 통신 구조의 모델과 앞으로 개발될 프로토콜의 표준적인 뼈대를 제공하기 위해 개발된 참조 모델이다.

## TCP/IP Model

> 미국에서 개발한 인터넷 기본 통신 트로토콜이다. DOD Model을 기반으로 개발되었다.  
현재 실질적으로 사용되고 있는 모델이다. OSI 7 계층은 장비 개발자들이 어떻게 표준을 잡을지 결정하기 위해 많이 사용한다.

- TCP: 연결지향형 프로토콜. 세션의 연결과 종료, 흐름제어, 패킷의 분할 및 재조립에 사용
- IP: 비연결 지향형 프로토콜. 데이터 전송에 사용

5~7 계층에서 데이터가 생성된다.

1. Physical Layer(물리 계층)

  네트워크 통신을 위한 물리적인 표준을 정의하는 계층이다.
  
  두 컴퓨터 간의 전기적, 기계적, 절차적인 연결을 정의한다.
  
  ex) 케이블의 종류, 송수신 속도, 전기, 전압
  
  `Hub`, `Repeater`

2. Data Link Layer(데이터 링크 계층)

  물리적 계층을 통한 데이터 전송에 신뢰성을 더해주는 계층이다.
  
  Local Network에서 Frame을 안전하게 전송하는 것을 목적으로 한다.
  
  직접 연결되어 있지 않은 네트워크에 대해서는 상위 계층에서 오류 제어를 담당해야 한다.
  
  `Switch`, `Bridge`

3. Network Layer(네트워크 계층)

  Logical Address(IP Address)를 담당하고 Packet의 이동경로를 결정하는 계층이다.
  
  경로 선택(Routing), 논리적인 주소 정의
  
  Routing Protocol을 이용하여 Best Path를 선택한다.
  
  `Router`

4. Transport Layer(전송 계층)

  정보를 분할(`Segment`)하고 상대편에 도달하기 전에 다시 합치는 과정을 담당하는 계층이다.
  
  목적지에서 발신지 간의 통신에서 에러제어와 흐름제어를 담당한다.
  
  `TCP`, `UDP`

5. Session Layer(세션 계층)

  네트워크 상에서 통신할 경우, 양쪽 Host 간에 최초 연결이 이루어지게 하고, 통신 중 연결이 끊어지지 않도록 유지하는 역할을 하는 계층이다.
  
  -> 통신을 하는 Host 사이에서 세션을 열고, 닫고, 관리하는 기능을 담당한다.

6. Presentation Layer(표현 계층)

  전송하는 데이터의 Format(구성 방식)을 결정하는 계층이다.
  
  다양한 데이터 Format을 일관되게 상호변환하고 압축, 암호화, 복호화 기능을 수행한다.

7. Application Layer(응용프로그램 계층)

  사용자 인터페이스의 역할을 담당한다.
  
  `HTTP`, `FTP`, `Telnet`, `SMTP`, `DNS`, `TFTP`


# HTTP (HyterText Transfer Protocol)
네트워크 상에서 정보를 주고받을 수 있는 프로토콜이다. 포트는 `80`번을 사용한다. 현재 `HTTP/2`까지 나와있다.

HTTP는 TCP/IP 위에서 동작한다. HTTP는 클라이언트와 서버 사이에 이루어지는 요청·응답 프로토콜이다. 
웹브라우저가 HTTP를 통하여 서버에 요청하면 서버는 요청에 맞는 응답을 클라이언트에게 전달한다.

## HTTP 동작 방식
1. ISP(Internet Service Provider)를 통해 DNS 서버로부터 IP를 취득한다.
2. **3-way-handshake**를 통해 서버와 클라이언트 간에 세션을 생성한다. 일종의 초기화 과정을 거친다.
3. 통신을 마칠 때가 되면 **4-way-handshake**를 통해 세션을 종료한다.

![image](https://user-images.githubusercontent.com/37951612/80857968-2957fc00-8c91-11ea-8666-b8c22b82a4a3.png)

## 3-way-handshake

TCP 장치들 사이에서 **논리적인 연결을 정립**하는 과정이다.

TCP/IP 프로토콜을 이용하여 통신할 때, 응용프로그램과의 통신이 이루어지기 전에 정확한 전송을 보장하기 위해 
사전에 **세션을 시작**하는 과정이다.

![image](https://user-images.githubusercontent.com/37951612/80858037-979cbe80-8c91-11ea-918b-10b15fe5a9c4.png)

1. TCP Client는 TCP Server에 `SYN(n)` 패킷을 전송해서 접속을 요청한다.
2. TCP Server는 `SYN` 메시지를 받고 `SYN(n+1)` 메시지와 함께 메시지를 확인했다는 `ACK(m)` 패킷을 전송한다.
3. TCP Client는 `SYN`과 `ACK`를 수락하고 다시 `ACK(m+1)`(응답)를 전송하면 두 노드 간에 연결이 성립(Establish Connection)된다.

- SYN(Synchronize sequence number)

  연결을 요청하고 세션을 성립하는 데에 이용한다.

- ACK(Acknowledgement)

  받은 시퀀스 번호에 TCP 계층의 길이 또는 양을 더한 것과 같은 값을 담는다.

## 4-way-handshake

TCP 간의 **세션을 종료**하기 위한 과정이다.

![image](https://user-images.githubusercontent.com/37951612/80858024-88b60c00-8c91-11ea-87a1-3362bf97ac7c.png)

1. Client가 종료를 알리는 `FIN FLAG`를 Server에 전송한다.
2. Server는 `FIN` 패킷을 정상적으로 받았다는 `ACK`를 Client에 전송한다. 그 후 Server는 `CLOSE-WAIT` 상태가 된다.
3. 연결을 종료한 후 Server는 Client에게 `FIN FLAG`를 전송한다.
4. Client는 Server가 전송한 `FIN FLAG`를 받고 확인을 알리는 `ACK`를 Server에 전송한다. 그 후 Client는 일정시간동안 `TIME-WAIT` 상태가 된다.
5. Server는 Client로부터 `ACK`를 받고 소켓을 Close한다. 두 TCP 간의 세션이 종료된다.
6. Client는 `TIME-WAIT`에 빠져서 Server로부터 `FIN`을 수신해도, 일정시간동안 세션을 유지하며 도착하지 않은 패킷을 기다린다.

- FIN(Finish)
  
  세션의 종료를 알리며, 더이상 보낸 데이터가 없음을 표시한다.


# [네트워크 개론] 네트워크를 구성하는 장치

## 네트워크 구성

Ethernet의 경우, 네트워크가 구성되기 위해 필요한 장비는 아래 4개가 대표적이다.

1. NIC

  컴퓨터를 네트워크에 연결하기 위한 확장 포트

2. LAN 케이블

  컴퓨터를 물리적으로 연결하기 위한 케이블

3. Hub

  LAN 케이블의 집선 장치로, 여러 대의 컴퓨터를 연결한다.

4. Router

  서로 다른 네트워크를 연결하기 위한 기기다.
  
> 컴퓨터 -> NIC(컴퓨터와 네트워크 연결) -> LAN 케이블(NIC과 공유기 연결) -> (Hub, Switch) -> Router

### NIC(Network Interface Card)
컴퓨터를 네트워크에 연결하기 위해 꼭 필요한 확장 보드다.

우리가 흔히 아는 랜카드다.

컴퓨터로부터 발생한 데이터를 전기적 신호로 변환하여 송신하며, 수신하는 경우에는 전기적 신호를 원래의 데이터로 복원하여 컴퓨터에 전달한다.

-> 네트워크와 컴퓨터 사이의 중개자 역할을 한다.


### LAN(Local Area Network) 케이블

물리적으로 컴퓨터와 컴퓨터 사이를 연결하는 케이블이다.

LAN 카드에서 변환된 전기적 신호는 LAN 케이블을 타고 이동한다.

> IP 공유기와 Hub는 비슷한 역할을 하지만 약간의 차이점이 있다.


### IP 공유기

IP 주소를 할당하는 장치다. 공유기는 이론적으로 255개의 장비에 IP를 할당할 수 있으며 이를 통해 인터넷이 가능하게 만들어준다.

보통 공유기는 WAN 포트와 LAN 포트(랜선을 연결할 수 있는)가 있다. WAN 포트에 통신사에서 제공해주는 선을 연결하면 나머지 포트 아무곳에나 케이블을 연결해서 인터넷을 이용할 수 있다.


### Hub(허브)

LAN 케이블의 집선 장치다. 하나의 Hub에는 여러 개의 LAN 케이블을 연결할 수 있다.

Hub에는 WAN 포트가 없다. 또한 IP를 할당하는 기능도 없다. Hub의 주요한 역할은 할당된 IP를 많은 장치가 사용할 수 있도록 분배하는 것이다.


### Switch(스위치)

Hub와 거의 같은 역할을 한다. 하나의 네트워크 라인에 여러 대의 컴퓨터를 연결할 수 있도록 분배하는 역할을 한다.

두 장비(Hub와 Switch)의 가장 큰 차이점은 데이터 전송 대역이다. Hub는 전송 대역이 10Mbps인 경우, 5대의 컴퓨터를 연결했을 때 각 2Mbps의 대역폭을 가진다. Switch는 5대의 컴퓨터를 연결했을 때 10Mbps의 대역폭을 모든 컴퓨터에 동시적용할 수 있다. Hub가 한쪽 컴퓨터로만 데이터를 전송할 수 있기 때문이라고 이해하자.


### Router(라우터)

서로 다른 네트워크를 연결하는 역할을 한다.

LAN과 인터넷을 연결하거나, 지사 간의 LAN을 연결하여 WAN을 구축할 때 필요하다.



# [네트워크 개론] 네트워크 서비스 - DHCP

> 서비스란 서버가 네트워크에서 제공하는 기능들을 말한다. ex) 호스트 간 파일 공유  
이러한 서비스는 컴퓨터가 자신의 자원을 공유하거나 네트워크 전체를 원활하게 관리 및 운영하기 위해 반드시 필요하다.

## DHCP(Dynamic Host Configuration Protocol)

**클라이언트의 네트워크 할당이나 IP 주소 할당을 자동화하는 역할**을 한다.

클라이언트가 DHCP 서버에 요청을 보내면, DHCP 서버는 클라이언트에게 서버가 가지고 있는 IP Pool에서 사용 가능한 IP를 할당해준다.

DHCP는 보통 라우터에 같이 탑재되지만, 별도로 서버에도 설치할 수 있다.

### IP 임대(Lease)

**DHCP가 클라이언트에게 특정 기간동안 IP 주소를 빌려주는 것을 말한다.**

임대 기간은 보통 8일 정도이며, 임대 기간이 끝나면 DHCP의 IP Pool에 반환하여 유동인구가 많은 도심지의 경우 이 기간을 짧게(2~3시간) 설정하여 IP가 빠른 회전율을 갖도록 한다.

#### DHCP DORA(Discover, Offer, Request, ACK)

1. DHCP Discover

  IP주소를 갖고 있지 않은 클라이언트는 MAC 주소를 기반으로 IP 주소를 할당받는다.
  
  IP 주소를 할당하기 위해서는 로컬 네트워크의 Discover Packet을 Broadcast한다. 해당 호스트가 속한 네트워크의 모든 호스트에게 패킷이 전달되지만, DHCP 서버를 제외한 모든 호스트는 패킷을 파기한다. DHCP 서버에 Discover Packet이 정상적으로 도착한 경우, DHCP Offer를 시작한다.

2. DHCP Offer

  현재 DHCP 서버는 클라이언트로부터 Discover Packet을 수신한 상태다. 그 후 Offer Packet을 Broadcast한다. MAC 주소에는 Discover Packet을 발행한 호스트의 MAC 주소를 담아서 송신하게 된다.

3. DHCP Request

  현재 클라이언트는 DHCP 서버의 Offer Packet을 받았고, 해당 패킷을 수신함으로써 DHCP가 같은 네트워크 안에 존재한다고 판단했다. 클라이언트는 DHCP로부터 IP를 할당받기 위해 Request Packet을 송신하며, DHCP Server가 클라이언트가 보낸 Request Packet을 수신할 경우 DHCP ACK 과정으로 넘어간다.

4. DHCP ACK

  DHCP 서버는 클라이언트가 Request Packet을 수신했다. 이후 IP 풀에서 할당할 수 있는 IP를 찾기 시작한다. 일반적으로 가장 앞쪽에 비어있는 IP부터 할당하게 된다. 할당할 IP를 찾은 경우, IP 주소를 패킷에 담아서 응답하고 클라이언트가 해당 패킷을 정상적으로 수신했다면 IP가 할당된다.

> 하나의 네트워크에 DHCP 서버가 여러 대면?

DHCP에서 4단계에 걸쳐서 IP를 할당하는 이유가 DHCP 서버가 여러 대일 경우에 대비하기 위해서다.

하나의 네트워크에 여러 대의 DHCP 서버가 존재하는 경우, 네트워크 내의 모든 DHCP 서버에 클라이언트가 보낸 Discover Packet이 송신된다. 패킷을 받은 모든 서버는 해당 패킷이 등록된 MAC 주소로 응답하고, 클라이언트는 여러 개의 Offer Packet을 수신하게 된다. 이 때 클라이언트가 하나의 Offer Packet에만 응답함으로써 한 대의 DHCP 서버로부터 하나의 IP만 할당받을 수 있다.


> 고정 IP를 사용하는 경우는?

DHCP는 해당 서버에서 임대 가능한 IP 풀 범위 내에서 IP를 할당하기 때문에 사용 중인 IP인지 잘 모른다. 만약 고정 IP로 사용중인 IP를 클라이언트에 임대해주면 IP가 충돌하는 현상이 일어날 것이다.

이 때 IP 주소 풀을 옮기거나 DHCP 예약기능을 통해 해당 IP에 대해 임대기간을 `-1`로 설정하면 무한대에 가까운 임대기간 동안 IP를 이용할 수 있다.


### IP 갱신(Renewal)

DORA 중 RA(Request, ACK)만 재실행된다. IP가 정상적으로 임대된 경우, IP 갱신은 두 번 일어난다.

1. 임대시간이 50% 지났을 때
2. 임대시간이 87.5% 지났을 때

임대 갱신 동안 네트워크의 불안정이나 DHCP 서버의 불안정으로 제대로 임대갱신이 이루어지지 않을 경우를 대비하기 위해서 두 번 임대갱신한다.


### IP 반환(Release)

IP 임대기간이 끝나면 IP를 DHCP 서버에 반환한다.


### DHCP Relay Agent

일반적으로 Broadcast Packet은 라우터(게이트웨이) 밖으로 넘어가지 못한다. 가정에 존재하는 PC의 경우, 공유기로부터 사설 IP를 할당 받아 쓰기 때문에 DHCP 서버가 라우터 밖에 존재하는 경우가 없지만, 기업의 경우 DHCP 서버가 라우터 밖에 존재하는 경우가 있다.

이 경우, 패킷이 라우터 바깥 영역으로 전달될 수 있도록 Unicast Packet으로 변환하여 전송해야 한다.

DHCP Relay Agent가 하는 역할이 이것이다.


# [네트워크 개론] 네트워크 서비스 - DNS

## DNS(Domain Name Server)

네트워크에서 호스트명으로부터 대응하는 IP 주소를 검색하여 취득하는 서비스다.

네트워크에 존재하는 모든 컴퓨터는 IP주소를 가지고있으며, 통신이 이루어질 때 이 IP 주소를 통해 대상을 식별한다.

하지만 IP 주소는 사람이 기억하기 힘들기때문에 이 불편을 해소하기 위해 여러가지 대안책이 나왔고, 그 중 하나가 DNS다.


## DNS 종류

1. Primary(Master)

  도메인을 가지기 위해 기본이 되는 서버다.

2. Secondary(Slave)

  Priamry 서버의 백업 용도로 존재하는 서버다.

3. Caching Only

  캐싱 역할을 하는 서버다. 검색된 기록이 있는 주소 정보를 저장했다가 빠르게 응답할 수 있다.

![image](https://user-images.githubusercontent.com/37951612/80860894-d177c000-8ca5-11ea-86e1-9e179576d383.png)


## DDNS

실시간으로 DNS를 갱신하는 서버다. 도메인의 IP가 유동적인 경우, IP가 바뀌어도 DDNS로 설정한 도메인 값은 변하지 않는다.

하지만 이 유동 IP가 변경된 경우, 해당 도메인에 접속 시 엉뚱한 곳으로 연결된다.  이런 이유로 DDNS는 보통 유동 IP로 인터넷을 공급받는 사용자들이 개인서버나 NAS를 구축할 때 많이 사용한다.



# Load Balancing (로드밸런싱, 부하분산)

컴퓨터 네트워크 기술의 일종으로, 둘 혹은 셋 이상의 중앙처리장치 혹은 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것을 의미한다.

부하를 나누기 때문에 가용성 및 응답시간을 최소화시킬 수 있다.

로드 밸런싱은 트래픽의 과부하를 막기 위해 가상의 아이피(Virtual IP)를 통해 여러 대의 서버로 접속을 분배하는 것이다.

인터넷 서비스에는 소프트웨어를 이용한 부하분산이 적용되며, 소프트웨어는 서버와 클라이언트 중간에 위치하여 중개한다. 내부 네트워크 구조를 공개하지 않기 때문에 크래킹을 막을 수 있다.

![image](https://user-images.githubusercontent.com/37951612/80861766-7f399d80-8cab-11ea-8941-7a261ad16a65.png)

1. L2

  MAC Address를 이용한 스위칭을 하며, 외부 호스트에 접근할 수 있는 방법이 없다.
  
  상위 계층으로의 프로토콜 기반 스위칭이 불가능하다.

2. L3

  IP Address를 이용하며, L2 + Routing 기능을 가지고 있다.
  
  IP 주소를 이용하기 때문에 외부망에 있는 호스트에게도 스위칭이 가능하다.

3. L4

  TCP / UDP 프로토콜을 이용한다. IP Address와 Port를 기반으로 스위칭한다.

4. L7

  IP Address, Port, 패킷을 내용을 통해 스위칭한다.

> 보통 상위 계층에 있는 스위치는 하위 계층의 스위칭을 지원한다. 하지만 각 계층에는 고유의 문제점들이 존재한다. 최근에는 L4, L7을 많이 사용하는 추세다.

## L4 스위치

L4 스위치의 로드 밸런서는 중간의 스위치를 통해서 각각의 서버에 접속을 분산시켜 보내준다.

Transport Layer에서 동작하며, IP Address, Port, Session을 기반으로 한 로드밸런싱을 담당한다.

TCP / UCP 프로토콜을 이용하며 프로토콜의 헤더를 보고 로드밸런싱을 수행한다. 주로 Round Robin 방식을 이용한다.

### DSR (Direct Server Return) 모드
L4가 양방향 프록시라면 모든 웹서버가 받는 트래픽을 L4가 다 받아야 한다. DSR 모드를 켜면 응답 시 L4를 거치지 않고 출발지에 직접적으로 응답한다.

L4 스위치에서 제공하는 DSR 모드를 이용하면 스위치는 양방향에서 발생하는 모든 트래픽을 받는 게 아니라, 클라이언트에서 발생한 트래픽만 처리하게 된다.

### NAT (Network Access Translation)
TCP/UDP 포트 숫자와 Source, Destination IP 등을 재기록하여 라우터를 통해 네트워크 트래픽을 주고 받는 기술이다.

사설 네트워크에 속한 여러 개의 호스트가 하나의 공개 IP(Public IP)를 통해 접속하는 것을 목적으로 한다.

### L4 스위치를 사용하는 경우 / 사용하지 않는 경우

사용하는 경우
1. 요청 패킷이 적은 경우
2. 일반적인 웹 요청
3. 파일 다운로드

사용하지 않는 경우
1. 요청 패킷이 많은 경우
2. 파일 업로드 등
3. SMTP


## L7 스위치
Application Layer에서 동작하는 스위치이며, 이메일의 제목, HTTP의 URL, FTP의 파일명, 쿠키 정보, payload 정보 등을 분석하여 좀 더 정교한 로드밸런싱(장비, 서버 세분화)이 가능하다.

L7 스위치는 L4 스위치보다 보안적으로 우수하다. 데이터 분석을 통해 DDoS 공격 방어가 가능하고, 감염 패킷의 필터링이 가능하다.

### 주요 기능
- 전송 제어

  IP Header, Payload 등 패킷을 분석한다.

- 로드밸런싱

  HTTP, URL 등 내용에 기반하여 부하를 분산한다.

- QoS(Quality of Service)
  
  세션별, 유저별, 애플리케이션별 대역 관리

- 모니터링

  응용 프로그램 수준의 트래픽 감시 및 통제


## L4, L7 스위치의 차이점
L4 스위치의 세션 관리 -> 스위치

서버가 여러 대인 경우, 첫 요청과 두번째 요청 시 연결되는 서버가 다를 수 있다. 따라서 세션의 유지가 이루어지지 않는다.

이런 경우엔 L4 스위치에서 **Sticky Session**이라는 기능을 사용한다.

해당 기능을 사용하면 **A 사용자가 1번 서버와 세션을 생성한 경우, 일정 시간(timeout)동안 해당 서버와 추가적인 연결을 시켜준다**.

하지만 여기서도 문제가 발생한다. 프록시 서버가 있는 경우에는 외부망으로 통신이 이루어질 때 프록시 서버의 IP를 가지고 통신이 이루어진다. 따라서 같은 내부망의 여러 호스트가 같은 외부망에 지속적으로 요청하면 한 서버에 트래픽이 몰릴 수 있다.

모두 같은 프록시의 IP를 통해 요청이 외부로 전송되기 때문이다. 이 때 Cookie를 사용하면 문제를 적절하게 해결할 수 있다.

L7 스위치의 세션 관리 -> Client - Switch의 세션과 Switch - Server의 세션을 각각 맺어서 두 세션을 연결해서 관리

L7 스위치는 두 가지 방식을 사용하여 부하를 분산한다. 새로 추가된 것도 있다.

1. URL 스위칭

  URL 주소를 확인하여 설정에 알맞은 서버로 부하를 분산한다.
  
  ex) `base-url/image`, `base-url/api`

2. Cookie 스위칭

  HTTP Header의 Cookie 값 설정에 따라 스위칭될 서버를 결정한다.

3. L7 Content 스위칭

  Content(내용)를 기반으로 스위칭한다. HTTP Header과 XML Content를 기반으로 스위칭의 타켓이 결정된다.
  
  Cookie와 HTTP Header의 Insertion과 Delete를 포함한 contents-rewirte를 지원하며, 도메인의 redirecting request 또한 지원한다.

## L4, L7 스위치의 성능 지표
- 초당 연결수(Connections Per Second)

  (3-way-handshake를 통해) TCP 세션 오픈의 시간 당 처리 개수

- 동시 연결수(Concurrent Connections)

  동시 세션 유지 개수

- 처리 용량(Throughput)

  (패킷 자체에 연결이 성립되는) UDP 프로토콜에 대한 로드밸런싱 성능 지표다. FWLB에서 중요하다.
  
  단위는 `bps(bit per second)` 또는 `pps(packet per second)`


# Protocol (프로토콜)

> 위키피디아: 통신 프로토콜 또는 통신규약은 컴퓨터나 원거리 통신 장비 사이에서 메시지를 주고 받는 양식과 규칙의 체계이다.

이 때 '규칙'에는 언어, 데이터가 송신된 과정, 데이터를 수신한 측에서 어떻게 원래의 데이터를 가질 수 있는지도 포함된다.

## 프로토콜 구성요소

### 구문(Syntax)
**데이터를 어떻게 구성할지**에 대한 형식, 구체적인 코딩 방법, 신호 레벨 등에 대한 형식을 규정한다.

### 의미(Semantic)
**데이터를 구체적으로 어떻게 제어할 것인지**에 대한 처리 방법, **에러가 발생했을 때 처리 방법**에 대한 정보를 포함한다.

### 타이밍(Timing)
통신이 이루어질 때 데이터를 주고 받을 때 **속도 조절**과 여러 데이터가 동시에 통신해야할 경우 **순서 관리**를 위한 기법을 포함한다.

## 계층적 역할 관점에서 보았을 때 - 프로토콜 구성요소
- 물리적 역할 측면

  자료 전송에 쓰이는 전송 매체, 접속용 단자 및 전송 신호, 회신 규격 등을 말한다.

- 논리적 역할 측면

  프레임의 구성, 프레임 내의 각 항목의 뜻과 기능, 자료 전송의 절차 등을 말한다.

## 프로토콜 기능

### 주소 설정(Addressing)
통신하기 위해서는 통신의 대상이 누군지 알아야 한다. 프로토콜에는 ***각 전송 계층에 맞는 주소를 지정하는 기능**이 있다.

### 순서 제어(Sequence Control)
데이터가 전송될 때에는 PDU(Protocol Data Unit)을 통해 하나의 데이터를 여러 개의, **각 프로토콜에 맞는 단위로 쪼개서 전송**하게 된다.

순서 제어는 프로토콜 데이터 단위가 전송될 때 순서를 명시하는 기능이며, 연결지향형(ex. TCP Protocol)에서만 사용한다. 순서를 지정하는 이유는 흐름제어, 혼잡제어, 오류제어를 위해서다.

**순서제어에 의해 정해진 PDU를 수신 측에 보내면 순서에 맞게 데이터를 재구성한다.**

### 분할 및 재조립(Fragmentation & Reassembly)
큰 데이터를 전달하는 것은 통신에 있어 비효율적이기때문에 **하나의 데이터를 전송 효율이 높은 작은 단위로 분할하여 전송**하고 수신 측에서는 해당 데이터를 사용하기 위해 **재조립**하는 과정을 거친다.

### 캡슐화(Encapsulation)
**PDU(Protocol Data Unit)은 PCI(Protocol Control Unit)와 SDU(Service Data Unit)로 구성**된다.

- PCI

  각종 헤더 정보를 담고 있다. ex) Source Address, Destination Address, 순서 번호, FCS 등

- SDU

  실제 서비스 데이터 정보를 담고 있다.

통신을 구성하는 각 Layer를 통과하기 위해 캡슐화를 통해 포장하는 과정을 거친다. 데이터를 사용하기 위해서는 캡슐화된 데이터는 **수신측에서 역캡슐화** 하는 과정을 통해 각각의 Layer를 통과한다.

### 흐름 제어(Flow Control)
**송신 측에서 전달하는 데이터의 양이나 속도를 조절하는 기능**이다. 송신과 수신 사이의 속도차이로 인한 데이터 유실을 방지한다.

### 오류 제어(Error Control)
**PDU로 데이터를 교환할 때 SDU나 PCI가 잘못되었는지 발견하는 기법**이다.

오류 제어는 순서를 검사하거나 특정 시간 안에 데이터를 받지 못하면 재전송을 요구하는 방식으로 이루어진다.

### 동기화(Synchronization)
**송수신측 간의 데이터를 주고 받는 시점을 정확하게 일치시키기 위한 기법**이다.

### 멀티플렉싱(Multiplexing)
**하나의 통신 선로에서 시스템이 동시에 통신할 수 있는 기법**이다.

### 전송 서비스
우선 순위 결정, 서비스 등급과 같은 보안 요구 등을 제어하는 서비스를 말한다.



# [OSI 참조모델 & TCP/IP] TCP/IP란?

인터넷에서 표준을 사용되고 있는 네트워크 프로토콜로, IP(Network Layer)를 중심으로 한 여러 프로토콜의 집합체를 총칭하여 부르는 것이다.

![image](https://user-images.githubusercontent.com/37951612/80862810-d55e0f00-8cb2-11ea-94b3-cd3f2557f0b9.png)


# [OSI 참조모델 & TCP/IP] 메시지 구조와 종류

## 메시지

일반적으로 네트워크 장비 사이에서 오고 가는 데이터를 말한다.

메시지를 사용하는 계층이나 프로토콜에 따라 패킷, 데이터그램, 프레임, 셀, 세그먼트 등 다양한 이름으로 불린다.

### 메시지 구조

- Header

  제어 정보와 관련된 바이트 단위의 데이터다.
  
  예를 들어, 데이터 송신 시 네트워크 계층에서 목적지의 IP 주소를 메시지에 담는다 했을 때 4계층(= 전송 계층)에서 넘어온 캡슐화된 데이터는 3계층(= 네트워크 계층)에서 생성되는 메시지의 헤더에는 목적지의 주소가 담겨서 캡슐화가 진행된다.

- Payload(= Data)

  전송하고자 하는 실제 데이터가 들어간다.
  
  캡슐화가 진행될 때 데이터 영역을 갖지 않고 있는 메시지들은 데이터가 전송되기 전 논리적인 연결을 맺거나 끊을 때 사용된다.

- Footer(= Tailer)

  Header와 크게 다르지 않다. 제어 정보를 담고 있다. 하지만 데이터를 통해 산출된 결과를 통해 제어하는 데이터를 관리한다.
  
## PDU & SDU
**PDU(Protocol Data Unit)은 PCI(Protocol Control Unit)와 SDU(Service Data Unit)**로 구성된다.

### PDU
같은 계층의 네트워크끼리 주고 받는 메시지의 단위를 말한다. ex) Network Layer - Packet. 패킷은 3계층에서 사용하는 PDU다.

### SDU
실제로 서비스되는 데이터라는 의미다. 네트워크 통신을 위해 각 계층에서 만들어진 메시지는 캡슐화를 통해 다음 계층으로 넘어가는데, 캡슐화가 이루어진 후 상위 계층 -> 하위 계층 또는 하위 계층 -> 상위 계층 으로 전달되는 실제로 유용한 데이터를 말한다.

### PDU = 각 계층의 메시지
- 패킷(Packet)

  3계층(네트워크 계층)에서 작동하는 프로토콜이 전송하는 메시지를 말한다.

- 프레임(Frame)

  2계층(데이터 링크 계층)과 연관성이 높다. 1계층(물리 계층)에서 메시지 포매팅이 일어날 때 사용하기도 한다.

- 데이터그램(Datagram)

  OSI 계층 중 상위 계층(5 - 세션 계층, 6 - 표현 계층, 7 - 응용프로그램 계층)에서 주로 사용하는 단위다.

- 셀(Cell)

  OSI 계층 중 하위 계층과 연관성이 높다. 셀의 크기느 고정적이다.

> TCP의 메시지는 세그먼트라고 불린다. 이처럼 PDU 명칭은 계층과 프로토콜에 따라 다르다.



# 이더넷(Ethernet)과 Mac 주소(MAC Address) - 1계층과 2계층 프로토콜

## 이더넷(Ethernet)

컴퓨터 간 네트워크를 구축하기 위한 방법론 중 하나이다. 전세계 90% 이상의 네트워크가 구축 방식으로 이더넷을 이용한다.

이더넷은 3계층(네트워크 계층)으로부터 받은 패킷(데이터)에 프레임의 처음을 나타내는 **프리앰블(preamble)**과 **Destination(목적지 = 수신자)**, **Source(출발지 = 송신자)**를 나타내는 헤더, 비트 오류 체크에 사용하는 **FCS(Frame Check Sequence)**를 추가하여 프레임을 만든다.

이더넷에서는 MAC 주소를 이용하여 컴퓨터 간의 네트워크가 가능하게 된다.


## MAC 주소(MAC Address)

MAC 주소는 48bit로 표현된 식별자를 이용하여 컴퓨터를 구분한다.

MAC 주소는 8bit 단위로 콜론이나 하이픈을 통해 16진수로 표기하여 나타낸다. 상위 24bit는 IEEE로부터 할당받은 제조업체 코드이며, 하위 24bit는 제조업체에서 기기를 구분하기 위한 고유한 값이다.

MAC 주소는 NIC(Nerwork Interface Card). 즉 랜카드에 할당되며 전세계에서 하나밖에 존재하지 않는 고유한 값이다. 컴퓨터가 데이터를 송신할 때 자신의 MAC 주소를 출발지 MAC 주소로, 상대방의 MAC 주소를 목적지 MAC 주소로 해서 헤더에 넣고 프레임(2계층의 PDU)을 생성한다.



# 스위칭(Switching): 이더넷의 데이터 통신 방법

> 이더넷 네트워크는 어떻게 구성되는가?

이더넷은 **스위치**라는 네트워크 기기를 중심으로 컴퓨터를 배치해서 스타형 토폴로지 형태를 만든다.

스위치는 다량의 LAN 포트를 가지고 있는 2계층의 네트워크 기기다. 유선 LAN 케이블을 이용하여 컴퓨터와 스위치를 연결하게 되면 여러 대의 컴퓨터가 하나의 LAN을 구성하게 된다.

## 스위치 동작 방식
1. LAN 케이블을 통해 스위치로 프레임이 들어온다.
2. 스위치는 LAN 포트번호, 프레임을 보낸 기기의 MAC 주소를 통해 MAC 주소 테이블을 작성한다.

-> 데이터 전송 시 MAC 주소 테이블을 통해 정확한 목적지를 찾아 전송하기 때문에 불필요한 프레임이 전송될 일이 없고, 네트워크 통신 효율을 향상할 수 있다.

-> 이렇게 스위치를 통해 수행하는 프레임 전송을 스위칭이라고 한다.

## MAC 주소 테이블에 대상이 존재하지 않으면?

스위칭 발생 과정 중 주소 정보가 없으면, 스위치는 네트워크에 연결된 모든 컴퓨터에 프레임의 복사본을 전송한다.

프레임을 받은 컴퓨터는 자신에게 와야 하는 프레임이 맞으면 수취하고 아닌 경우에는 프레임을 파기한다.

그리고 MAC 주소 테이블에는 새로운 정보가 갱신된다.



# 라우터(Router)와 라우팅(Routing): IP를 바탕으로 한 패킷의 전송

라우터는 이미 구성된 이더넷 네트워크들을 연결시켜주는 네트워크 계층 장비다.

라우터는 이미 만들어진 **라우팅 테이블**을 이용하여 패킷을 전송한다. 라우터가 수행하는 패킷 전송을 **라우팅**이라고 한다.

라우터는 파우팅 테이블을 통해 목적지(Destination) 네트워크와 목적지 네트워크로 가기 위해 경유해야 하는 곳의 IP 주소(= Next Hop = 넥스트 홉)를 관리한다.

라우터가 패킷을 받게 되면 라우팅 테이블을 조회해서 목적지를 파악하고 존재하면 IP 주소를 통해 전달한다. 반면 라우팅 테이블에 존재하지 않는 목적지면 패킷을 파기한다.


## 라우팅 테이블 작성 방법
- 정적 라우팅

  관리자가 직접 라우팅 테이블에 목적지 네트워크의 정보를 입력하는 방법으로 관리한다.
  
  소규모 네트워크에 적합하다.

- 동적 라우팅

  인접하는 라우터들이 라우팅 정보를 서로 교환하여 라우팅 테이블을 자동으로 구축한다.
  
  정보를 교환할 때 다양한 알고리즘을 사용하며, 네트워크 변화에 용이하고 장애 내구성을 향상할 수 있다.
  
  중간 ~ 대규모 네트워크에 적합하다.
  

## L3 스위치
일반적인 스위치는 2계층(데이터 링크 계층)에서 작동하며 MAC 주소를 이용한 통신 방식을 사용한다.

L3 스위치는 3계층(네트워크 계층) 프로토콜인 `IP`, `IPX`를 이용하여 통신을 수행한다.

IP(네트워크 주소)를 이용하기 때문에 네트워크 간 통신이 가능하다. 또한 **네트워크 간 통신이 가능하기 때문에 L3 스위치 자체에 IP를 할당받아서 라우터 역할을 대행하기도 한다.**



# ARP(Address Resolution Protocol): 목적지의 MAC 주소를 알기 위한 장치

ARP는 MAC 주소와 IP 주소를 연결해주는 역할을 한다.

3계층을 통해 2계층으로 내려온 패킷이 어떻게 프레임을 만들까?

프레임의 이더넷 헤더에는 출발지의 MAC 주소, 목적지의 MAC 주소를 추가하게 된다. 출발지의 MAC 주소는 호스트의 NIC에 적혀있는 MAC 주소를 통해 알수 있지만, 목적지의 MAC 주소는 알 수 없다.

목적지의 MAC 주소를 비워둔 채로 통신을 진행하면 수신 측의 2계층에서는 프레임을 파기한다.

따라서 ARP 통신을 이용해 목적지의 MAC 주소를 알아내야 한다.

> 컴퓨터끼리 통신할 때마다 통신 데이터의 IP 주소는 출발지부터 목적지까지 변하지 않지만, MAC 주소는 NIC를 경유할 때마다 변경된다. 이 변경되는 MAC 주소를 통해 적절한 목적지를 찾아간다.

## ARP의 동작 과정

> 두 개의 호스트가 통신을 하기 전에 ARP가 동작한다.

![image](https://user-images.githubusercontent.com/37951612/80865712-1e6b8e80-8cc6-11ea-8972-9e5fd4b5b894.png)

1. 호스트에 존재하는 **APR 테이블에서 IP 주소를 조회**한다.

  **같은 네트워크에 존재하는 호스트의 경우, ARP를 통해 조회한다. 다른 네트워크에 존재하는 호스트인 경우, 게이트웨이(= Router)의 IP 주소를 조회한다.**

2. ARP 테이블에서 목적지의 정보를 얻지 못한 경우, **브로드캐스트를 통해 ARP 요청**한다.
3. 네트워크에 존재하는 호스트들은 브로드캐스트로 발생한 ARP 요청을 받고 해당하는 호스트는 자신의 **ARP 테이블에 송신자 정보를 갱신하고 유니캐스트를 통해 ARP Reply를 응답한다. 나머지 호스트는 요청을 파기&&한다.
4. 응답받은 호스트는 **ARP Reply를 통해 자신의 ARP 테이블에 내용을 추가**하고, ARP Process가 종료된다.



# TCP & UCP: 4계층 프로토콜

- TCP(Transmission Control Protocol) -> 정확성을 우선시한다.

  TCP에서는 두 노드 간의 세션 확립을 위해 `3-way-handshake` 과정이 이루어지고, 세션 종료 시 `4-way-handshake` 과정을 통해 세션ㅇ르 종료한다.
  
  패킷은 지속적으로 송신과 수신에 대한 메시지를 주고받으며, 패킷이 정확히 전달 및 취득되었는지 지속적인 확인을 진행한다.
  
  이렇게 높은 신뢰성을 제공하는 TCP는 주로 웹, 메일, 파일 공유 등 정확한 데이터의 전송을 필요로 하는 서비스에 적합하다.

- UDP(User Datagram Protocol) -> 신속성을 우선시한다.

UCP에서는 데이터 신뢰성보다는 신속한 데이터 전달을 우선시한다.

TCP와는 다르게 데이터를 전송만 하면 전송 여부와 수신 여부에 대해서는 별다르게 판단하지 않기 때문에 TCP보다 상대적으로 과정이 간단하다. -> 빠른 속도를 기대할 수 있다.

UDP는 VolP나 시간 동기, 이름 해결(호스트명 + 도메인명에 대응하는 IP 주소를 가르쳐주는 과정) 등과 같은 서비스에 사용한다.

## 서비스 식별법
TCP와 UDP는 포트 번호를 이용하여 컴퓨터 안의 어떤 서비스에 데이터를 전달해야할지 알아낸다. 포트번호는 `0~65535`를 사용하며 크게 3가지로 분리된다.

- `0~1023`

  **Well-known Port**
  
  일반적인 소프트웨어가 클라이언트의 서비스 요청을 대기할 때 사용하는 포트 번호다.

- `1024~49151`

  **Registered Port**
  
  제조업체의 독자적인 소프트웨어가 클라이언트의 서비스 요청을 대기할 때 사용한다.

- `49152~65535`

  **Dynamic Port**
  
  서버가 클라이언트를 식별하기 위해 사용한다.


## Port 번호의 사용

**Request와 Response 과정에서 포트를 사용하는 방식**

![image](https://user-images.githubusercontent.com/37951612/80867073-20851b80-8ccd-11ea-9f5f-acea8eb2bf99.png)

1. Application 계층에서부터 내려온 데이터는 L4에서 출발지 포트 번호와 목적지 포트 번호를 담아서 하위 계층으로 이동한다.
2. 각 계층에서는 계층에서 담당하는 정보를 헤더에 담아서 목적지로 발송하게 된다.
3. 패킷이 목적지 컴퓨터에 도착하게 되면 하위 계층부터 상위 계층으로 올라가면서 역캡슐화(decapsulation)를 진행한다.
4. 4계층(전송 계층)에 도착하면 TCP 헤더에 담긴 목적지 포트 번호를 확인하고 해당 포트번호에 대해 대기 중인 서비스에 OS에 의해 연결된다.

> 응답의 경우, 기본적으로 목적지 포트 번호를 알고 있기 때문에 요청(Request) 작업과 동일한 방법으로 응답 과정이 진행된다.



# SSL(Secure Socket Layer) & HTTPS: 인터넷 보안

**SSL**은 데이터를 암호화하거나 통신 상대를 인증함으로써 **데이터를 보호**한다.

**HTTPS**는 HTTP over SSL의 약자로, **HTTP 통신을 SSL로 암호화**하여 이용하는 프로토콜이다.

일반적으로 서버에서는 SSL을 이용하기 위해 **소프트웨어**를 이용한다. 오픈소스 프로그램인 OpenSSL과 Window Server에 기본으로 내장되어 있는 IIS가 있다.


## SSL의 보안 유지 방식

SSL에서는 데이터를 보호하기 위해 세 가지 방법을 이용한다.

1. **암호화**

  **도청을 방지**한다.
  
  정해진 규칙에 근거하여 데이터를 변환하는 기술이다.

2. **메세지 다이제스트**

  **변조를 방지**한다.
  
  데이터로부터 고정 길이 데이터를 추출한다.

3. **디지털 증명서**

  **위장을 방지**한다.
  
  통신을 하는 상대가 내가 원하는 상대인지 증명하는 파일이다.


## SSL 암호화 방식

- **공통키 암호화 방식**

  통신을 수행하는 두 주체 간에 암호화에 사용되는 공통된 키를 가지고 진행하는 암호화 방식이다.
  
  클라이언트와 서버가 공통된 키를 소유하고 있고, 데이터를 암호화하는 키와 복호화하는 키가 동일하기 때문에 키가 유출되면 문제가 발생한다.
  
  서로에게 키를 전달하는 방식에 대해 고민해봐야 한다. 공개키를 이용한 암호화, 복호화하는 과정이 간단하고 처리 부하가 낮다.

- **공개키 암호화 방식**

  공개키와 비밀키를 이용하는 암호화 방식이다.

  서버에서 공개키와 비밀키를 발급하여 통신하는 클라이언트에게 공개키를 노출시키면 클라이언트는 서버와 통신할 때, 공개키를 통해 암호화하고 암호화된 데이터는 비밀키를 가지고 있는 서버에서만 복호화를 진행할 수 있다.
  
  공통키 암호화 방식과는 다르게 공개키가 유출되어도 큰 문제점이 없다. 대신 공개키 암호화 방식은 데이터를 처리하는 과정이 복잡하기 때문에 처리 부하를 고려해야 한다.
  

## SSL 통신 상대 증명

SSL은 통신 상대를 판별하기 위해 디지털 인증서를 사용한다. -> 인증 서버에는 디지털 증명서가 설치되어있어야 한다.

1. 관리자는 서버 소프트웨어에서 비밀키와 공개키를 작성한 후 공개키를 CSR(Certificate Signing Request)과 함께 인증국(CA 기관)에 제출한다.
2. 인증국은 판단 후 CSR에 디지털 서명을 찍어서 디지털 증명서로서 관리자에게 반환한다.
3. 관리자는 인증국으로부터 받은 디지털 인증서를 서버에 설치한다.


## SSL 암호화 과정

인증서가 서버에 정상적으로 설치되면 클라이언트의 SSL 서비스 요청을 받을 수 있는 상태가 된다. 서버와 클라이언트가 진행하는 SSL 암호화 과정을 알아보자.

1. 서버는 클라이언트가 연결해오면 공개키와 디지털 서명을 포함한 디지털 증명서를 반환한다.
2. 클라이언트는 디지털 서명을 보고 디지털 증명서가 올바른 것인지 체크한다. 올바른 증명서라면 공통키의 데이터를 공개키로 암호화하여 서버에 전달한다.
3. 서버에 도착한 데이터를 서버는 자신의 비밀키로 복호화하고 공통키로 데이터를 꺼낸다.
4. 클라이언트와 서버는 공통키의 재료로부터 공통키를 만들어서 이후에는 그것으로 암호화 통신을 수행한다.

> 1~3에 대한 과정을 SSL handshake라고 부른다.

![image](https://user-images.githubusercontent.com/37951612/80868337-e1f35f00-8cd4-11ea-9ea3-ceb2335be28d.png)



# SSL/TLS: TLS 협상 

> 앱 클라이언트가 서버로 보낸 요청이 도착하지 않는 문제. 그런데 브라우저에서는 아주 잘 요청이 온다.  
특정 앱에서만 통신이 안되는 상황이었고, 네트워크는 ACL만 잘 설정되어 있으면 문제가 없을 것이라고 생각했는데 클라이언트의 TLS 버전이 낮아서 HTTPS의 인증 부분을 담당하는 로드밸런서에서 TLS 협상 오류가 발생할 수 있다.  
-> TLS 협상 오류가 뭘까?

## TLS(Transport Layer Security)
- `SSL 3.0` 기반으로 IEFT가 만든 **3-way-handshake 인터넷 암호화 통신 프로토콜**
- HTTP의 Security 뿐만 아니라 **Application Layer에서 Security를 사용할 수 있다.**
- `TLS 1.3` 버전이 **정식 승인**되었다.
- **무결성, 인증, 기밀성이 보장**된다.

최신의 웹사이트에서는 보안적인 측면때문에 모두 HTTPS 통신을 이용한 네트워크 통신을 사용한다.

TLS 또한 Application Layer에서 동작할 수 있고, HTTPS Protocol이 동작할 수 있도록 해준다.


## TLS 협상 오류

서버와 클라이언트 간 세션을 생성하기 위해서는 handshake 과정이 필요한데, 그 과정이 정상적으로 수행되지 못하고 오류가 발생하는 경우다.

ex) AWS 환경에서 작업 -> TLS 협상 오류가 발생하는 원인에 대하여 AWS 도큐먼트를 보면 다음과 같이 말해준다.

> 클라이언트 TLS 협상 오류는 클라이언트가 시작한 TLS 연결을 의미하며 로드 밸런서와 세션을 설정할 수 없는 것을 의미한다. 클라이언트가 로드 밸런서의 보안 정책이 지원하지 않는 프로토콜 또는 암호를 사용하여 로드 밸런서에 연결하려고 할 때 TLS 협상 오류가 발생한다.

-> **클라이언트의 TLS 버전을 확인**하자.

-> **클라이언트의 TLS 버전을 당장 수정할 수 없는 상황이라면 좀 더 폭넓은 버전과 호환되는 정책을 사용하면 일단의 클라이언트와 서버 간의 통신 문제는 해결된다.**

> 현재는 많은 브라우저나 웹 서버에서 TLS 1.2 미만 버전에 대해서 지원이 되지 않는다. 다수의 메이저 웹 브라우저에서도 2020년 상반기까지 TLS1.0 및 TLS1.1 버전에 대한 지원을 완전히 삭제할 예정이라고 공지 되었다고 한다.


# 커버로스(Kerberos) 프로토콜

## 커버로스
커버로스(Kerberos)는 티켓(Ticket)을 기반으로 동작하는 컴퓨터 네트워크 인증 암호화 프로토콜이다. 비 보안 네트워크에서 통신하는 노드가 보안 방식으로 다른 노드를 식별할 수 있게 허용한다.

클라이언트 - 서버 모델을 목적으로 개발되었으며, 사용자와 서버가 서로 식별할 수 있는 상호 인증(양방향 인증)을 제공한다.

커버로스 프로토콜의 메세지는 도청과 재전송 공격으로부터 보호된다. 커버로스는 대칭키 암호 방식을 빌드되며 TTP(신뢰되는 써드파티)를 요구한다. 또, 특정 인증 구간에서 비대칭키 암호 방식을 이용함으로써 선택적으로 공개키 암호 방식을 사용할 수 있다. 커버로스는 기본적으로 `88`번 포트를 사용한다.

## 요약
커버로스(Kerberos)는 **클라이언트 - 서버 구조에서** **서버 접근권한에 대한 관리를 위해** **대칭키 방식을 이용하여 인증하는 네트워크 인증 암호화 프로토콜**이다.

## 사용하는 경우
- 서버와 유저의 수가 증가함에 따라 사용자와 권한에 대한 관리 비용이 높아지는 경우
- 서버 별로 접근 가능한 사용자를 관리해야할 때
- 서버가 추가될 때마다 혹은 유저가 추가/삭제될 때마다 유저를 등록 및 관리해야하는 경우

## 커버로스 동작 과정

- Client, AS, TGS, SS
- 대칭키(공통키) 암호화

- **Client**

  **서비스를 제공**받는다.

- **AS(Authentication Server)**

  **인증을 제공**한다.

- **TGS(Ticket Granting Server)**

  **티켓을 발행**한다.

- **SS(Service Server)**

  **서비스를 제공**한다.


![image](https://user-images.githubusercontent.com/37951612/80869010-d99d2300-8cd8-11ea-8e12-faa91eace7c4.png)


### 사용자 클라이언트 기반 로그인 (Client <-> User)
1. 클라이언트는 사용자로부터 아이디와 비밀번호를 입력받는다.
2. 비밀번호를 대칭키로 변환하여 암호키를 생성한다.

### 클라이언트 인증 (Client <-> AS)
3. 클라이언트는 AS에게 사용자 아이디를 전송한다.
4. AS는 사용자 아이디로 DB를 조회하고 두 개의 메시지를 생성한다.

  - 메시지 A

    클라이언트 비밀번호를 기반으로 Client / TGS 세션 키 생성

  - 메시지 B

    TGS의 비밀키로 TGT를 암호화

  - TGT

    **TGT = Client ID + Network IP + Expired Time + TGS Session Key**

5. 만들어진 암호키를 기반으로 메시지 A를 해독하고 TGS 세션 키를 획득한다. 클라이언트는 TGS 비밀키를 가지고 있지 않으므로 해독하지 않고 가지고 있다.


### 고객 서비스 인증 (Client -> AS의 TGS -> Client)
6. 클라이언트는 메시지 A, B를 통해서 메시지 C, D를 생성한다.

  - 메시지 C

    **TGT + Service ID**

  - 메시지 D

    **Client ID + Timestamp**

    위의 정보를 TGS 세션 키로 암호화되어 생성된 메시지는 AS의 TGS로 전송된다.

7. TGS는 메시지 C, D를 기반으로 메시지 E, F를 생성한다.

  - 메시지 E
  
    Client to Server Ticket -> Server Secret Key로 암호화한다.
    
    (TGS와 SS는 Server Secret Key를 알고 있으므로 해독할 수 있다.)
  
  - 메시지 F
  
    Client / Server Session Key -> Client / TGS 세션 키로 암호화한다.

  여기서 생성된 메시지는 클라이언트에게로 전송한다.


### 고객 서비스 요청 (Client -> SS)
8. 메시지 D, F를 받은 사용자는 서비스를 이용할 자격을 갖추게 된다. 클라이언트는 서비스를 제공받기 위해 메시지 E, G를 SS에게 전송한다.

  - 메시지 E

    7에서 받은 Client to Server Ticket

  - 메시지 G

    Client ID + Timestamp -> Client / Server 세션 키로 암호화한다.

9. SS는 메시지 E, G를 이용해 클라이언트의 신원을 확인하고 정보가 일치하는 경우, 메시지 H를 통해 Client에게 신원을 확인시켜 준다.

  - 메시지 H
  
    메시지 D의 Timestamp + 메시지 G의 Timestamp -> Client / Server 세션 키로 암호화한다.
    
10. 메시지 H를 받은 Client는 해독 후 Timestamp를 확인하고 SS에 서비스를 요청하기 시작한다.


### 커버로스 프로토콜의 단점

- 사용자가 증가하면서 과도한 티켓 생성 시, 서버 부하가 크게 발생할 수 있다.
- AS(Authentication Server) 다운 시 인증과정이 중단된다.
- 각 서버의 시간 설정이 잘못되어있는 경우, 인증 과정에서 문제가 발생한다.

  Timestamp를 이용하므로

- 프로토콜의 표준화가 진행되지 않아서 서버마다 구현이 상이하다.


# Domain Name & Host Name

## 도메인 네임(Domain Name)
넓은 의미로는 **네트워크 상에서 컴퓨터를 식별하는 호스트명**을 가리킨다.

좁은 의미로는 **도메인 레지스트리에 등록된 이름**을 의미한다.

-> 네트워크 상에서 원하는 호스트를 가리키는 이름 정도로 생각하면 된다.

## 호스트 네임(Host Name)
**네트워크에 연결된 장치들에 부여되는 각각의 고유한 이름**이다.

우리가 도메인 주소를 생성하면 서비스를 구분하기 위해 별도의 서브 도메인을 사용하기도 한다.

ex) `mail.naver.com`, `comic.naver.com` -> `mail`과 `comic`은 `naver.com`이라는 도메인 네임에서 각각의 서비스를 구분하기 위한 호스트 네임이다.

> 즉, 네트워크를 구성하고 네트워크 안에서 IP 주소가 아닌 별칭(ex. 호스트네임)을 사용하기 위해서는 호스트 네임과 IP 주소를 관리해주는 테이블이 필요하다.  
네트워크의 게이트웨이(라우터)를 통해 대상자에 대한  IP 주소와 호스트 네임을 관리한다.  
때문에 내부 네트워크를 이용하는 경우 별도로 호스트네임을 등록해두고 IP 주소가 아닌, 호스트네임을 통해 ssh 접속을 하거나 ping 테스트를 진행할 수 있다.
