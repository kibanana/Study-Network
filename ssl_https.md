## [SSL(Secure Sockets Layer) 이란?](https://offbyone.tistory.com/274)
웹서버와 브라우저 간의 통신을 암호화해서 중간에 누가 가로채더라도 내용을 알 수 없게 해준다. 
SSL을 적용하면 `https://` 를 사용하여 웹서버에 접근한다.

### SSL과 TLS
**SSL(Secure Sockets Layer)** 와 **TLS(Transport Layer Security)** 는 같은 것이라고 할 수 있다. 
SSL은 **TCP/IP 암호화 통신에 사용되는 규약** 으로서, 넷스케이프에서 만들었다. `SSL v3.0`부터는 IETF에서 표준으로 정해서 `TLS 1.0`이 되었다. 
하지만 SSL이라고 많이 부른다.

### 대칭키 암호화, 비대칭키 암호화
SSL에서는 데이터를 암호화해서 전송하는데, 이 방식에는 두 가지가 있다.
- **대칭키 암호화(Symmetric Key)**: 하나의 키로 암호화, 복호화 한다. ex) `AES`
- **비대칭키 암호화(Asymmetric Key)**: 두 개의 키로 각각 암호화, 복호화 한다. ex) `RSA`
  
  A Key로 암호화 => B Key로 복호화, B Key로 암호화 => A Key로 복호화  
  자신만 갖는 키를 **개인키(Private Key)** 라 부르고, 다른 하나는 상대방에게도 공개하며 그것을 **공개키(Public Key)** 라고 부른다.
  그래서 비대칭키 암호화 방식을 **공개키 암호화 방식**이라고도 한다.  
  
서버와 클라이언트가 같은 키를 사용해야하므로 키를 공유하는 데에 문제가 있고, 
비대칭키 암호화는 키 공유 문제는 없지만 처리 속도가 느린 문제가 있다.  
=> HTTPS 통신에서, 실제 전송되는 **데이터 암호화에는 대칭키 암호화 방식을 사용**하고, **키 교환에는 비대칭키 암호화를 사용**한다.

### 인증기관(Certification Authority, CA)
HTTPS 통신에서는 제 3자가 인증을 해준다. 인증기관(CA)으로부터 공인인증서를 발급받아서 서버에 설치해야 한다. 인증기관의 인증을 받았다는 것은 웹서비스 제공자를 보증해준다는 의미다.정확히는, **웹서비스 제공자의 공개키가 키 소유자의 것이라는 것을 보증**해준다는 것이다.

`HTTPS`로 **웹서비스를 제공하는 사람**은 자신의 공개키, 개인키를 생성하고 **공개키를 인증기관에 보낸다.** 인증기관에서는 보내온 공개키, 유효기간, 도메인 등의 정보를 포함하여 인증기관의 개인키로 전자서명한 인증서를 발급한다. 웹서비스 제공자는 발급 받은 인증서와 자신의 개인키를 웹서버에 설정하여 `HTTPS` 통신을 할 수 있게 된다. **웹브라우저에는 이미 여러 인증기관의 공개키를 포함한 인증서가 설치되어 있다.** 그래서 **웹서버와 통신 시 인증기관의 개인키로 서명된 인증서를 받았을 때, 이미 설치되어 있는 인증기관의 공개키로 복호화가 가능하다.**

### SSL 동작 방식
> 상황: 인증기관으로부터 인증서를 발급받아서 웹서버에 설치하고, HTTPS 통신이 가능한 상태가 되었다.
1. 사용자가 웹브라우저로 사이트에 접속한다. **웹서버는 (인증기관의 개인키로 암호화된 사이트의 정보와 공개키가 들어있는)인증서를 웹 브라우저에 보낸다.**
2. 웹브라우저는 이미 가지고 있는 인증기관의 **공개키로** 웹 서버에서 받은 인증서를 **복호화**한다.
3. 웹브라우저는 **실제 데이터의 암호화에 사용될 대칭키**를 인증서에서 꺼낸 웹서버 측의 **공개키로 암호화**해서 웹서버로 보낸다.
4. 웹서버는 자신이 가진 **개인키로 웹브라우저가 보낸 대칭키를 복호화**한다. 이제 이 대칭키로 **데이터를 암호화**하고 송수신한다.

실제로는 데이터 전송을 위해 다양항 암호화 방식을 선택할 수 있고, 키 교환 방식도 다를 수 있다.

### SSH(Secure Socket Layer) / TLS(Transport Layer Security)

**컴퓨터 네트워크에서 통신 보안을 제공하는 암호화 프로토콜** 로, 웹 브라우저, 전자메일, 인터넷 팩스, 인스턴트 메시징 및 VoIP와 같은 응용프로그램에서 널리 사용된다. **웹사이트의 경우 TLS** 를 사용하여 서버와 웹 브라우저 간 모든 통신을 보호할 수 있다.

전송계층과 응용계층 사이에 독립적으로 위치한다.

1. 서버와 클라이언트는 연결(세션, Session)마다 고유한 암호키(=> **SSL Handshake Protocol** 이 결정)를 공유하는 DES, RC4 같은 대칭키 암호화 알고리즘 으로 보안을 제공한다.
2. 서버와 클라이언트 상호 인증(ex. 공개키 암호 알고리즘, 전자서명 알고리즘, 공개키 인증서)이 이루어진다.
3. 메시지 인증 코드를 이용하여 메시지 무결성을 보장한다.

### SSL Handshake Protocol

![image](https://user-images.githubusercontent.com/37951612/78139027-d0fbc780-7462-11ea-8c1a-b346d39b716c.png)

인증서를 교환하여 서로를 인증하고, 공유키를 생성하여 암호화된 통신을 수행한다.

1. **Client** hello

    자신이 사용할 SSL의 버전, Cipher suite list, 클라이언트 난수를 생성하여 보낸다.

2. **Server** hello

    암호화 방법을 선택하고 서버 난수를 생성하여 보낸다.

3. **Server** Certificate

    클라이언트는 CA의 공개키로 인증서를 해독하여 **서버의 공개키** 를 획득한다.

    클라이언트는 클라이언트와 서버의 난수를 각각 사용하여 **Pre-Master Secret** 값을 생성하고, **서버의 공개키**로 암호화하여 서버에게 보낸다. **서버는 개인키**로 해당 암호문을 복호화한다.

    암호문의 복호화가 제대로 이루어지면, **서버**는 클라이언트에 **인증**을 마친다.

4. **Server** Key Exchange

    인증서가 없거나, 인증서가 서명용으로만 사용될 때 메시지를 보낸다

5. Certificate Request **(Server -> Client)**

    클라이언트에 인증서를 요구한다(암호 제품군에 따라 과정 자체 여부가 달라질 수 있다)

6. **Server** hello done

    서버가 클라이언트에게 보낼 메시지를 모두 보냈음

7. **Client** Certificate

    클라이언트의 인증서를 개인키로 암호화하고 클라이언트 인증서 공개 키를 사용하여 확인한다.

8. Certificate Verify **(Client -> Server)**

    클라이언트의 인증서를 서버가 쉽게 확인할 수 있도록 전자서명하고 서버에게 보낸다. 해당 메시지를 통해 서버는 클라이언트 인증서 공개 키가 유효한자 확인하고 **클라이언트 인증**을 마친다.

9.  **Client** Key Exchange

    PMS(Pre-Master Secret, 일종의 난수값), Client 난수, Server 난수를 이용하여 **암호화키**와 **메시지 인증 코드용 공유키**를 생성한다.

10. Change Cipher Spec **(Client -> Server)**

    이후에 전송되는 모든 메시지를 (서버와 협상된 알고리즘과 키를 이용하여) 암호화 시키겠다고 서버에 알린다. 직후, Finished 메시지를 생성하여 서버에 전송한다.

11. Finished **(Client <-> Server)**

    클라이언트와 SSL 서버 간 SSL 핸드쉐이크 종료


---


## [HTTPS와 SSL 인증서, SSL 동작방법](https://wayhome25.github.io/cs/2018/03/11/ssl-https/)

> 생활코딩의 https와 ssl 인증서 수업 + HTTP 완벽가이드 14장: 보안 HTTP

> 일반적으로,
공개키로 암호화를 하는 경우 데이터를 보안하는 것을 중요하게 생각할 때 사용하게 되고
개인키로 암호화를 하는 경우(공개키로 복호화)는 인증 과정을 중심으로 생각할 때 사용하게 됩니다.

**HTTPS는 HTTP를 안전하게 만드는 방식**이다.

![image](https://user-images.githubusercontent.com/37951612/86534510-f8f04080-bf13-11ea-8420-1535ce55ee67.png)

- HTTP(Hypertext Transfer Protocol)

  - 인터넷 상에서 정보를 주고받기 위한 프로토콜
  - 클라이언트와 서버 사이의 요청 및 응답 프로토콜
  - 암호화되지 않은 방법으로 데이터를 전송
    
    -> 악의적인 감청 또는 데이터 변조의 가능성

- HTTPS(Hypertext Transfer Protocol Over Secure Socket Layer)

  - 보안이 강화된 HTTP
  - 모든 HTTP 요청 및 응답 데이터는 네트워크로 보내지기 전, 암호화된다.
  - HTTPS는 HTTP의 하부에 보안 계층(ex. SSL)을 제공함으로써 동작한다(그 아래에는 TCP나 UDP가 있다).

  ![image](https://user-images.githubusercontent.com/37951612/86534514-03123f00-bf14-11ea-90c3-34b5cc05febd.png)
  
### SSL 디지털 인증서
**클라이언트와 서버 간의 통신을 공인된 CA 업체(제 3자)가 보증해주는 전자화된 문서**

- SSL 인증서의 장점 및 역할
  
  - 통신 내용이 노출되어 변조되는 것을 방지
  - 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 확인
  - SSL 통신에 사용할 (서버의) 공개키를 클라이언트에 제공

### SSL 암호화

- 암호

  아무나 정보에 접근하지 못하도록 인코딩하는 알고리즘

- 키

  암호의 동작을 변경하는 매개변수
  
  키에 따라서 암호화의 결과가 달라지기 때문에, 키를 모르면 복호화가 불가능하다.
  
- **대칭키 암호화 방식**

  - 암호화와 복호화에 같은 키를 사용하는 알고리즘
  - 발송자와 수신자가 서로 같은 정보를 공유하기 위해서는 둘 다 같은 키를 가져야하므로 대칭키를 전달하는 과정에서 키가 유출되면 전달하려는 내용을 복호화할 수 있음로 위험하다는 단점이 있다.
  
  -> 이를 보안하기 위해 공개키 암호화 방식이 나왔다.

- **공개키 암호화 방식**

  - 암호화와 복호화에 다른 키를 사용하는 알고리즘
  - 공개키(Public Key)는 말 그대로 공개되어 있으며, 보통 디지털 인증서 안에 포함되어 있다.
  - 개인키(Private Key)는 호스트만이 해당 키를 알고 있다.
  - 공개키와 개인키의 분리는 메시지의 암호화는 누구나 할 수 있도록 하는 동시에 메시지의 복호화는 반대 키의 소유자만 할 수 있도록 한다.
  - 연산이 느리다는 단점이 있다.
  
  -> 클라이언트가 서버로 안전하게 메시지를 발송하는 것을 쉽게 해준다.


### 디지털 서명

![image](https://user-images.githubusercontent.com/37951612/86534824-8e8ccf80-bf16-11ea-8cd2-9986c75bb292.png)

- 전자서명을 통해 누가 메시지를 썼는지 알려주고, 메시지가 위조되지 않았음을 증명할 수 있다.
- 전자서명은 SSL 인증서에서 서비스를 보증하는 방법으로써 활용된다.
- 공개키와 개인키는 안전한 데이터를 전달하는 목적 이외에도, 데이터 제공자의 신원을 보장하는 데에 사용할 수 있다.
- 개인키의 소유자가

  1. 개인키를 이용해서 정보를 암호화
  2. 공개키와 함께 암호화된 정보를 전송
  3. 수신자는 공개키로 암호화된 정보를 복호화
  
- 암호화된 데이터를 공개키로 복호화할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 개인키에 의해서 암호화되었다는 것을 의미한다.

  -> 즉, 공개키가 데이터를 제공한 사람의 신원을 보장해주게 된다.


### CA(Certificate Authority)

**디지털 인증서를 제공하는 공인된 기업**

- 대표적인 CA 서비스 제공 기업과 시장점유율
  - Symantec (VeriSign, Thawte, Geotrust) with 42.9% market share
  - Comodo with 26%
  - GoDaddy with 14%
  - GlobalSign with 7.7%


### SSL 인증서의 서비스 보증방법 및 동작방법

- 인증서 내용

  인증서의 내용은 CA의 개인키를 이용해서 암호화되어 웹브라우저(Client)에 제공된다.
  
  인증서의 내용에는 **서비스 정보(인증서 발급자, CA의 디지털 서명, 서비스 도메인)**, **Server 측 공개키**가 있다.


- SSL 인증서의 서비스 보증방법

  1. 웹 브라우저(Client)가 Server에 접속하면 Server는 제일 먼저 인증서를 제공한다.
  2. 브라우저(Client)는 인증서를 발급한 CA가 자신이 갖고 있는 CA 리스트에 있는지 확인한다.
  3. CA 리스트에 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화한다.
  4. 인증서를 복호화할 수 있다는 것은 이 인증서가 CA의 개인키에 의해 암호화되었다는 것을 의미한다. 즉, 데이터를 제공한 사람의 신원을 보장해주게 되는 것이다.

- SSL 동작방법 및 통신과정

  - 공개키 암호화 방식은 알고리즘 연산이 느린 경향이 있다.
  - 따라서 SSL은 암호화된 데이터를 송수신하기 위해 비대칭키 암호화 알고리즘과 대칭키 암호화 알고리즘을 혼합해서 사용한다.
  - 안전한 의사소통 채널을 수립하기 위해 비대칭키 암호화 알고리즘을 사용한다.
  - 위에서 만들어진 안전한 채널을 통해 임시의 무작위 대칭키를 생성 및 교환한다. 그리고 이 대칭키는 나머지 데이터의 암호화에 활용한다.
  
  **실제 데이터 암호화 방식**은 **대칭키**.
  
  실제 데이터를 암호화, 복호화하기 위한 **대칭키를 공유하기 위한 암호화 방식**은 **비대칭키(공개키)**.
  
  ![image](https://user-images.githubusercontent.com/37951612/86535112-d876b500-bf18-11ea-850d-3b10b38bb04d.png)
  
  1. Server와 Client가 네트워크를 통해서 통신할 때, Handshake -> Session -> Session End 과정을 거친다.
  2. 암호화된 HTTP 메시지를 교환하기 전, Server와 Client는 SSL Handshake를 진행한다.
  3. Handshake의 목적
    
      - 프로토콜 버전 번호 교환
      - 양쪽이 아는 Pre-master Secret Key 생성 및 교환
      - 양쪽의 신원 인증
      - 채널을 암호화하기 위한 임시 세션 키 생성


## [SSL과 인증서 구조 이해하기: CA(Certificate Authority) 중심](https://m.blog.naver.com/alice_k106/221468341565)

> 기초적인 네트워크 및 암호화 기술 지식을 알고 있다는 가정 하에 작성되었다. 그 중 필수적으로 알아야 하는 기술은 **비대칭키** 방식. 흔히 말하는 PKI(Public Key Infrastructure, 공개키 기반의 암호화 시스템)의 작동 원리를 반드시 이해해야 한다.

### 왜 인증서를 사용하는가?
네트워크를 통해 패킷을 주고 받는다. 그러나 전통적으로 네트워크는 공격의 위험이 있는 공간으로 간주되어 왔다. 우리가 특정 서버에 요청과 응답을 주고받을 때, 수많은 라우터와 스위치를 거치게 되는 게 그 중간에서 누군가가 우리의 패킷을 훔쳐볼(Sniffing) 수 있기 때문이다. 패킷을 훔쳐본다는 것은 결국 우리가 입력한 데이터 중에서도 비밀번호 같이 민감한 정보를 제3자가 열람할 수 있다는 뜻이기 때문에 이를 미연에 방지하기 위한 방법들이 연구되어 왔다.

![image](https://user-images.githubusercontent.com/37951612/86545230-6332d080-bf68-11ea-8916-e6df39a83574.png)

만약 데이터가 암호화된다면 네트워크에서 중간에 공격자가 패킷을 열람하더라도 정보가 유출되는 것을 막을 수 있다. 오늘날 가장 널리 쓰이고 있는 암호화 방식은 **SSL/TLS1**라고 하며, 이 방식은 **인증서**라는 일종의 서명을 사용한다. 인증서는 **당신을 신뢰할 수 있나?**를 확인하기 위한 용도로, 패킷 데이터를 암호화하기 위한 첫 단계라고 할 수 있다.

인증서를 이용한 검증 과정을 거치고나서야 비로소 데이터 암호화 작업이 수행된다. 그 과정이 SSL 보안 통신이며, 이론상 해독이 거의 불가능하기 때문에 오늘날 다양한 보안 연결에서 사용되고 있다. ex) 웹 브라우저와 웹 사이트 간 연결

웹 브라우저의 주소 옆에 있는 자물쇠는 인증서를 통해 브라우저와 서버 간의 보안 연결이 수립되었다는 것을 의미한다. 반대로 '주의 요함'이라는 문구가 출력되는 웹사이트는 데이터가 암호화되지 않은 채로 전송되고 있으며 네트워크에 존재할 수 있는 공격자가 스니핑, 스푸핑을 통해 패킷을 훔칠 때 데이터가 유출될 수 있음을 의미한다.

여러 컴포넌트가 네트워크 상에서 상호 통신할 때 Payload 데이터의 유출을 막기 위해 보안 연결을 위한 SSL 및 인증서 도입을 반드시 고려해야 한다(Open Stack이나 Kubernetes처럼 컴포넌트가 더욱 세분화되고 모듈화되어 있다면 더욱 그렇다 ex. Docker Daemon에 보안 인증서 적용). 실제 운영 환경에서 이런 작업은 필수적이다.

> 물론 돈을 지불하고 보안 대행 업체에게 보안 연결 및 인증서 관리를 위임할수도 있지만, 인증서 및 보안 연결의 동작 원리는 인프라 및 네트워크 관리 측면에서 매우 유용한 지식이다. 따라서 당신이 영상처리나 머신러닝과 같이 소스코드 레벨의 알고리즘에 올인하는 개발자가 아니라면 인증서의 구조는 반드시 이해하고 넘어가는 것이 좋다.

### 보안 연결의 순서

서버와 클라이언트 간 보안 연결은 크게 두 단계로 나뉜다.
1. 클라이언트가 CA를 통해 서버의 인증서를 신뢰할 수 있는지 확인하는 단계

  **당신(서버)는 신뢰할 수 있는 사람인가?**라는 것을 **인증서**를 통해 검증한다.
  
2. 클라이언트의 보안 연결 수립 단계

  서버와 클라이언트 간에 생성된 랜덤 값을 통해 대칭키를 생성하고, 이를 이용하여 네트워크 데이터를 암호화하여 전송한다.
  
결국 **인증서를 통한 신뢰 검증**이 완료되어야 **보안 연결 수립**이 가능하므로 인증서가 어떤 원리로 동작하는지 이해하는 것이 중요하다.

### 인증서의 구조

1. Root CA(최상위 인증기관, 인증서를 발급하는 기관)

  무조건 신뢰할 수 있는 기관 몇 군데 ex) Verisign, Geotrust ...
  
  이 기관들은 고유한 비밀키를 가지고 있고, 이에 대응되는 공개키는 전세계에 배포한다. 그리고 우리는 이 기관들을 신용할 수 있음을 서로 약속하고, 배포된 공개키로 복호화가 가능한 데이터는 이에 대응되는 비밀키로 암호화되었기 때문에 신용할 수 있는 데이터라고 간주한다.
  
  물론 비밀키가 철저한 보안 속에서, 절대로 유출되지 않아야만 한다는 전제 조건이 필요하지만 이런 기관은 보안을 전문으로 하는 회사이기 때문에 보통은 안전하다고 생각하면 된다.
  
  -> 지금 내 컴퓨터에도 이런 신뢰 가능한 기관의 공개키가 이미 설치되어 있을 것이다(MacOS라면 키체인에, 다른 운영체제라면 브라우저에).

---

위 질문과 답변 내용입니다. 혹시나 궁금해 하실 분이 있을까봐 올려둡니다. (확실하지 않음)

글 잘 읽었습니다. 인증서에 대해 이해하기 쉬웠습니다. 코스트 문제 때문에 궁금해서 여쭤보는데 아무리 찾아도 답이 안나와서 질문드립니다.공개키 알고리즘은 복호화와 암호화할때 비용(자원)이 많이 사용되는데 클라이언트가 CA list에 있는 것과 비교 할 때 서버에서 받아온 CA가 포함된 인증서를 공개키로 복호화하는 과정이 비용이 많이 들어갈 것 같습니다. 이때 복호화 과정에서 인증서 전체를 복호화 하는 건가요 ?

(여기서부터 답변)
클라이언트가 CA list에 있는 것과 비교할 때 서버에서 받아온 CA가 포함된 인증서를 공개키로 복호화하는 과정이 비용이 많이 들어갈 것 같습니다. 이 때 복호화 과정에서 인증서 전체를 복호화 하는 건가요?

-> 이 문장에 대해서 'CA List에 존재하는 모든 Public Key를 사용해서 서버의 인증서를 하나하나 복호화를 시도해보면 비용이 많이 소모되지 않을까' 라는 질문으로 이해하겠습니다. 그런 방식으로 검증을 한다면 당연히 비효율적일것 같습니다만, 보통 인증서에는 Issuer라고 하는 것과 그 인증서에 대한 메타데이터(DN)가 존재합니다. 복호화하기 이전에 먼저 메타데이터를 비교해 일치하는 인증서의 공개키로 복호화를 시도하지 않을까 싶습니다만.. 단순 메타데이터로 CA List에 존재 유무를 체크했는데 실패했다면 Self-signed 일수도 있는것이고 그때는 신뢰할 수 없게 되는것일테구요.

이것을 질문하신 것이 아니라 단순히 '비대칭키는 리소스가 많이 사용되는데 인증서 복호화는 비효율적이지 않느냐' 라는 말씀이시라면, 단순히 하나의 인증서에 대해 복호화는 그렇게 많이 소요될것 같지 않다는게 제 생각입니다. 최종적으로 SSL 연결 수립 뒤 대칭키로 통신을 하는 이유는 Payload가 단일 인증서 크기와 비교할 수 없을 만큼 클수도 있기 떄문이 아닐까요 ^^.. 만약 SSL 연결 수립 뒤 인증서 파일 크기만큼만을 복호화한다는 보장이 있으면 비대칭키를 사용하지 않을까 싶은데, 네트워크 연결이라는 것은 General한 경우를 상정해야 하니까요.

맞는 답변이 됐는지 모르겠습니다. 의도하신 내용이 아니라면 답글 부탁드립니다.
