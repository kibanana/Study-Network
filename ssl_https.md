## SSL(Secure Sockets Layer) 이란?
웹서버와 브라우저 간의 통신을 암호화해서 중간에 누가 가로채더라도 내용을 알 수 없게 해준다. 
SSL을 적용하면 `https://` 를 사용하여 웹서버에 접근한다.

### SSL과 TLS
**SSL(Secure Sockets Layer)** 와 **TLS(Transport Layer Security)** 는 같은 것이라고 할 수 있다. 
SSL은 **TCP/IP 암호화 통신에 사용되는 규약** 으로서, 넷스케이프에서 만들었다. `SSL v3.0`부터는 IETF에서 표준으로 정해서 `TLS 1.0`이 되었다. 
하지만 SSL이라고 많이 부른다.

### 대칭키 암호화, 비대칭키 암호화
SSL에서는 데이터를 암호화해서 전송하는데, 이 방식에는 두 가지가 있다.
- **대칭키 암호화(Symmetric Key)**: 하나의 키로 암호화, 복호화 한다. ex) `AES`
- **비대칭키 암호화(Asymmetric Key)**: 두 개의 키로 각각 암호화, 복호화 한다. ex) `RSA`
  
  A Key로 암호화 => B Key로 복호화, B Key로 암호화 => A Key로 복호화  
  자신만 갖는 키를 **개인키(Private Key)** 라 부르고, 다른 하나는 상대방에게도 공개하며 그것을 **공개키(Public Key)** 라고 부른다.
  그래서 비대칭키 암호화 방식을 **공개키 암호화 방식**이라고도 한다.  
  
서버와 클라이언트가 같은 키를 사용해야하므로 키를 공유하는 데에 문제가 있고, 
비대칭키 암호화는 키 공유 문제는 없지만 처리 속도가 느린 문제가 있다.  
=> HTTPS 통신에서, 실제 전송되는 **데이터 암호화에는 대칭키 암호화 방식을 사용**하고, **키 교환에는 비대칭키 암호화를 사용**한다.

### 인증기관(Certification Authority, CA)
HTTPS 통신에서는 제 3자가 인증을 해준다. 인증기관(CA)으로부터 공인인증서를 발급받아서 서버에 설치해야 한다. 인증기관의 인증을 받았다는 것은 웹서비스 제공자를 보증해준다는 의미다.정확히는, **웹서비스 제공자의 공개키가 키 소유자의 것이라는 것을 보증**해준다는 것이다.

`HTTPS`로 **웹서비스를 제공하는 사람**은 자신의 공개키, 개인키를 생성하고 **공개키를 인증기관에 보낸다.** 인증기관에서는 보내온 공개키, 유효기간, 도메인 등의 정보를 포함하여 인증기관의 개인키로 전자서명한 인증서를 발급한다. 웹서비스 제공자는 발급 받은 인증서와 자신의 개인키를 웹서버에 설정하여 `HTTPS` 통신을 할 수 있게 된다. **웹브라우저에는 이미 여러 인증기관의 공개키를 포함한 인증서가 설치되어 있다.** 그래서 **웹서버와 통신 시 인증기관의 개인키로 서명된 인증서를 받았을 때, 이미 설치되어 있는 인증기관의 공개키로 복호화가 가능하다.**

### SSL 동작 방식
> 상황: 인증기관으로부터 인증서를 발급받아서 웹서버에 설치하고, HTTPS 통신이 가능한 상태가 되었다.
1. 사용자가 웹브라우저로 사이트에 접속한다. **웹서버는 (인증기관의 개인키로 암호화된 사이트의 정보와 공개키가 들어있는)인증서를 웹 브라우저에 보낸다.**
2. 웹브라우저는 이미 가지고 있는 인증기관의 **공개키로** 웹 서버에서 받은 인증서를 **복호화**한다.
3. 웹브라우저는 **실제 데이터의 암호화에 사용될 대칭키**를 인증서에서 꺼낸 웹서버 측의 **공개키로 암호화**해서 웹서버로 보낸다.
4. 웹서버는 자신이 가진 **개인키로 웹브라우저가 보낸 대칭키를 복호화**한다. 이제 이 대칭키로 **데이터를 암호화**하고 송수신한다.

실제로는 데이터 전송을 위해 다양항 암호화 방식을 선택할 수 있고, 키 교환 방식도 다를 수 있다.

### SSH(Secure Socket Layer) / TLS(Transport Layer Security)

**컴퓨터 네트워크에서 통신 보안을 제공하는 암호화 프로토콜** 로, 웹 브라우저, 전자메일, 인터넷 팩스, 인스턴트 메시징 및 VoIP와 같은 응용프로그램에서 널리 사용된다. **웹사이트의 경우 TLS** 를 사용하여 서버와 웹 브라우저 간 모든 통신을 보호할 수 있다.

전송계층과 응용계층 사이에 독립적으로 위치한다.

1. 서버와 클라이언트는 연결(세션, Session)마다 고유한 암호키(=> **SSL Handshake Protocol** 이 결정)를 공유하는 DES, RC4 같은 대칭키 암호화 알고리즘 으로 보안을 제공한다.
2. 서버와 클라이언트 상호 인증(ex. 공개키 암호 알고리즘, 전자서명 알고리즘, 공개키 인증서)이 이루어진다.
3. 메시지 인증 코드를 이용하여 메시지 무결성을 보장한다.

### SSL Handshake Protocol

![image](https://user-images.githubusercontent.com/37951612/78139027-d0fbc780-7462-11ea-8c1a-b346d39b716c.png)

인증서를 교환하여 서로를 인증하고, 공유키를 생성하여 암호화된 통신을 수행한다.

1. **Client** hello

    자신이 사용할 SSL의 버전, Cipher suite list, 클라이언트 난수를 생성하여 보낸다.

2. **Server** hello

    암호화 방법을 선택하고 서버 난수를 생성하여 보낸다.

3. **Server** Certificate

    클라이언트는 CA의 공개키로 인증서를 해독하여 **서버의 공개키** 를 획득한다.

    클라이언트는 클라이언트와 서버의 난수를 각각 사용하여 **Pre-Master Secret** 값을 생성하고, **서버의 공개키**로 암호화하여 서버에게 보낸다. **서버는 개인키**로 해당 암호문을 복호화한다.

    암호문의 복호화가 제대로 이루어지면, **서버**는 클라이언트에 **인증**을 마친다.

4. **Server** Key Exchange

    인증서가 없거나, 인증서가 서명용으로만 사용될 때 메시지를 보낸다

5. Certificate Request **(Server -> Client)**

    클라이언트에 인증서를 요구한다(암호 제품군에 따라 과정 자체 여부가 달라질 수 있다)

6. **Server** hello done

    서버가 클라이언트에게 보낼 메시지를 모두 보냈음

7. **Client** Certificate

    클라이언트의 인증서를 개인키로 암호화하고 클라이언트 인증서 공개 키를 사용하여 확인한다.

8. Certificate Verify **(Client -> Server)**

    클라이언트의 인증서를 서버가 쉽게 확인할 수 있도록 전자서명하고 서버에게 보낸다. 해당 메시지를 통해 서버는 클라이언트 인증서 공개 키가 유효한자 확인하고 **클라이언트 인증**을 마친다.

9.  **Client** Key Exchange

    PMS(Pre-Master Secret, 일종의 난수값), Client 난수, Server 난수를 이용하여 **암호화키**와 **메시지 인증 코드용 공유키**를 생성한다.

10. Change Cipher Spec **(Client -> Server)**

    이후에 전송되는 모든 메시지를 (서버와 협상된 알고리즘과 키를 이용하여) 암호화 시키겠다고 서버에 알린다. 직후, Finished 메시지를 생성하여 서버에 전송한다.

11. Finished **(Client <-> Server)**

    클라이언트와 SSL 서버 간 SSL 핸드쉐이크 종료


---


## [HTTPS와 SSL 인증서, SSL 동작방법](https://wayhome25.github.io/cs/2018/03/11/ssl-https/)

> 생활코딩의 https와 ssl 인증서 수업 + HTTP 완벽가이드 14장: 보안 HTTP

**HTTPS는 HTTP를 안전하게 만드는 방식**이다.

![image](https://user-images.githubusercontent.com/37951612/86534510-f8f04080-bf13-11ea-8420-1535ce55ee67.png)

- HTTP(Hypertext Transfer Protocol)

  - 인터넷 상에서 정보를 주고받기 위한 프로토콜
  - 클라이언트와 서버 사이의 요청 및 응답 프로토콜
  - 암호화되지 않은 방법으로 데이터를 전송
    
    -> 악의적인 감청 또는 데이터 변조의 가능성

- HTTPS(Hypertext Transfer Protocol Over Secure Socket Layer)

  - 보안이 강화된 HTTP
  - 모든 HTTP 요청 및 응답 데이터는 네트워크로 보내지기 전, 암호화된다.
  - HTTPS는 HTTP의 하부에 보안 계층(ex. SSL)을 제공함으로써 동작한다(그 아래에는 TCP나 UDP가 있다).

  ![image](https://user-images.githubusercontent.com/37951612/86534514-03123f00-bf14-11ea-90c3-34b5cc05febd.png)
  
### SSL 디지털 인증서
**클라이언트와 서버 간의 통신을 공인된 CA 업체(제 3자)가 보증해주는 전자화된 문서**

- SSL 인증서의 장점 및 역할
  
  - 통신 내용이 노출되어 변조되는 것을 방지
  - 클라이언트가 접속하려는 서버가 신뢰할 수 있는 서버인지 확인
  - SSL 통신에 사용할 (서버의) 공개키를 클라이언트에 제공

### SSL 암호화

- 암호

  아무나 정보에 접근하지 못하도록 인코딩하는 알고리즘

- 키

  암호의 동작을 변경하는 매개변수
  
  키에 따라서 암호화의 결과가 달라지기 때문에, 키를 모르면 복호화가 불가능하다.
  
- **대칭키 암호화 방식**

  - 암호화와 복호화에 같은 키를 사용하는 알고리즘
  - 발송자와 수신자가 서로 같은 정보를 공유하기 위해서는 둘 다 같은 키를 가져야하므로 대칭키를 전달하는 과정에서 키가 유출되면 전달하려는 내용을 복호화할 수 있음로 위험하다는 단점이 있다.
  
  -> 이를 보안하기 위해 공개키 암호화 방식이 나왔다.

- **공개키 암호화 방식**

  - 암호화와 복호화에 다른 키를 사용하는 알고리즘
  - 공개키(Public Key)는 말 그대로 공개되어 있으며, 보통 디지털 인증서 안에 포함되어 있다.
  - 개인키(Private Key)는 호스트만이 해당 키를 알고 있다.
  - 공개키와 개인키의 분리는 메시지의 암호화는 누구나 할 수 있도록 하는 동시에 메시지의 복호화는 반대 키의 소유자만 할 수 있도록 한다.
  - 연산이 느리다는 단점이 있다.
  
  -> 클라이언트가 서버로 안전하게 메시지를 발송하는 것을 쉽게 해준다.


### 디지털 서명

![image](https://user-images.githubusercontent.com/37951612/86534824-8e8ccf80-bf16-11ea-8cd2-9986c75bb292.png)

- 전자서명을 통해 누가 메시지를 썼는지 알려주고, 메시지가 위조되지 않았음을 증명할 수 있다.
- 전자서명은 SSL 인증서에서 서비스를 보증하는 방법으로써 활용된다.
- 공개키와 개인키는 안전한 데이터를 전달하는 목적 이외에도, 데이터 제공자의 신원을 보장하는 데에 사용할 수 있다.
- 개인키의 소유자가

  1. 개인키를 이용해서 정보를 암호화
  2. 공개키와 함께 암호화된 정보를 전송
  3. 수신자는 공개키로 암호화된 정보를 복호화
  
- 암호화된 데이터를 공개키로 복호화할 수 있다는 것은 그 데이터가 공개키와 쌍을 이루는 개인키에 의해서 암호화되었다는 것을 의미한다.

  -> 즉, 공개키가 데이터를 제공한 사람의 신원을 보장해주게 된다.


### CA(Certificate Authority)

**디지털 인증서를 제공하는 공인된 기업**

- 대표적인 CA 서비스 제공 기업과 시장점유율
  - Symantec (VeriSign, Thawte, Geotrust) with 42.9% market share
  - Comodo with 26%
  - GoDaddy with 14%
  - GlobalSign with 7.7%


### SSL 인증서의 서비스 보증방법 및 동작방법

- 인증서 내용

  인증서의 내용은 CA의 개인키를 이용해서 암호화되어 웹브라우저(Client)에 제공된다.
  
  인증서의 내용에는 **서비스 정보(인증서 발급자, CA의 디지털 서명, 서비스 도메인)**, **Server 측 공개키**가 있다.


- SSL 인증서의 서비스 보증방법

  1. 웹 브라우저(Client)가 Server에 접속하면 Server는 제일 먼저 인증서를 제공한다.
  2. 브라우저(Client)는 인증서를 발급한 CA가 자신이 갖고 있는 CA 리스트에 있는지 확인한다.
  3. CA 리스트에 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화한다.
  4. 인증서를 복호화할 수 있다는 것은 이 인증서가 CA의 개인키에 의해 암호화되었다는 것을 의미한다. 즉, 데이터를 제공한 사람의 신원을 보장해주게 되는 것이다.

- SSL 동작방법 및 통신과정

  - 공개키 암호화 방식은 알고리즘 연산이 느린 경향이 있다.
  - 따라서 SSL은 암호화된 데이터를 송수신하기 위해 비대칭키 암호화 알고리즘과 대칭키 암호화 알고리즘을 혼합해서 사용한다.
  - 안전한 의사소통 채널을 수립하기 위해 비대칭키 암호화 알고리즘을 사용한다.
  - 위에서 만들어진 안전한 채널을 통해 임시의 무작위 대칭키를 생성 및 교환한다. 그리고 이 대칭키는 나머지 데이터의 암호화에 활용한다.
  
  **실제 데이터 암호화 방식**은 **대칭키**.
  
  실제 데이터를 암호화, 복호화하기 위한 **대칭키를 공유하기 위한 암호화 방식**은 **비대칭키(공개키)**.
  
  ![image](https://user-images.githubusercontent.com/37951612/86535112-d876b500-bf18-11ea-850d-3b10b38bb04d.png)
  
  1. Server와 Client가 네트워크를 통해서 통신할 때, Handshake -> Session -> Session End 과정을 거친다.
  2. 암호화된 HTTP 메시지를 교환하기 전, Server와 Client는 SSL Handshake를 진행한다.
  3. Handshake의 목적
    
      - 프로토콜 버전 번호 교환
      - 양쪽이 아는 Pre-master Secret Key 생성 및 교환
      - 양쪽의 신원 인증
      - 채널을 암호화하기 위한 임시 세션 키 생성

