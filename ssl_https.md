## SSL(Secure Sockets Layer) 이란?
웹서버와 브라우저 간의 통신을 암호화해서 중간에 누가 가로채더라도 내용을 알 수 없게 해준다. 
SSL을 적용하면 `https://` 를 사용하여 웹서버에 접근한다.

### SSL과 TLS
**SSL(Secure Sockets Layer)** 와 **TLS(Transport Layer Security)** 는 같은 것이라고 할 수 있다. 
SSL은 **TCP/IP 암호화 통신에 사용되는 규약** 으로서, 넷스케이프에서 만들었다. `SSL v3.0`부터는 IETF에서 표준으로 정해서 `TLS 1.0`이 되었다. 
하지만 SSL이라고 많이 부른다.

### 대칭키 암호화, 비대칭키 암호화
SSL에서는 데이터를 암호화해서 전송하는데, 이 방식에는 두 가지가 있다.
- **대칭키 암호화(Symmetric Key)**: 하나의 키로 암호화, 복호화 한다. ex) `AES`
- **비대칭키 암호화(Asymmetric Key)**: 두 개의 키로 각각 암호화, 복호화 한다. ex) `RSA`
  
  A Key로 암호화 => B Key로 복호화, B Key로 암호화 => A Key로 복호화  
  자신만 갖는 키를 **개인키(Private Key)** 라 부르고, 다른 하나는 상대방에게도 공개하며 그것을 **공개키(Public Key)** 라고 부른다.
  그래서 비대칭키 암호화 방식을 **공개키 암호화 방식**이라고도 한다.  
  
서버와 클라이언트가 같은 키를 사용해야하므로 키를 공유하는 데에 문제가 있고, 
비대칭키 암호화는 키 공유 문제는 없지만 처리 속도가 느린 문제가 있다.  
=> HTTPS 통신에서, 실제 전송되는 **데이터 암호화에는 대칭키 암호화 방식을 사용**하고, **키 교환에는 비대칭키 암호화를 사용**한다.

### 인증기관(Certification Authority, CA)
HTTPS 통신에서는 제 3자가 인증을 해준다. 인증기관(CA)으로부터 공인인증서를 발급받아서 서버에 설치해야 한다. 인증기관의 인증을 받았다는 것은 웹서비스 제공자를 보증해준다는 의미다.정확히는, **웹서비스 제공자의 공개키가 키 소유자의 것이라는 것을 보증**해준다는 것이다.

`HTTPS`로 **웹서비스를 제공하는 사람**은 자신의 공개키, 개인키를 생성하고 **공개키를 인증기관에 보낸다.** 인증기관에서는 보내온 공개키, 유효기간, 도메인 등의 정보를 포함하여 인증기관의 개인키로 전자서명한 인증서를 발급한다. 웹서비스 제공자는 발급 받은 인증서와 자신의 개인키를 웹서버에 설정하여 `HTTPS` 통신을 할 수 있게 된다. **웹브라우저에는 이미 여러 인증기관의 공개키를 포함한 인증서가 설치되어 있다.** 그래서 **웹서버와 통신 시 인증기관의 개인키로 서명된 인증서를 받았을 때, 이미 설치되어 있는 인증기관의 공개키로 복호화가 가능하다.**

### SSL 동작 방식
> 상황: 인증기관으로부터 인증서를 발급받아서 웹서버에 설치하고, HTTPS 통신이 가능한 상태가 되었다.
1. 사용자가 웹브라우저로 사이트에 접속한다. **웹서버는 (인증기관의 개인키로 암호화된 사이트의 정보와 공개키가 들어있는)인증서를 웹 브라우저에 보낸다.**
2. 웹브라우저는 이미 가지고 있는 인증기관의 **공개키로** 웹 서버에서 받은 인증서를 **복호화**한다.
3. 웹브라우저는 **실제 데이터의 암호화에 사용될 대칭키**를 인증서에서 꺼낸 웹서버 측의 **공개키로 암호화**해서 웹서버로 보낸다.
4. 웹서버는 자신이 가진 **개인키로 웹브라우저가 보낸 대칭키를 복호화**한다. 이제 이 대칭키로 **데이터를 암호화**하고 송수신한다.

실제로는 데이터 전송을 위해 다양항 암호화 방식을 선택할 수 있고, 키 교환 방식도 다를 수 있다.

### SSH(Secure Socket Layer) / TLS(Transport Layer Security)

**컴퓨터 네트워크에서 통신 보안을 제공하는 암호화 프로토콜** 로, 웹 브라우저, 전자메일, 인터넷 팩스, 인스턴트 메시징 및 VoIP와 같은 응용프로그램에서 널리 사용된다. **웹사이트의 경우 TLS** 를 사용하여 서버와 웹 브라우저 간 모든 통신을 보호할 수 있다.

전송계층과 응용계층 사이에 독립적으로 위치한다.

1. 서버와 클라이언트는 연결(세션, Session)마다 고유한 암호키(=> **SSL Handshake Protocol** 이 결정)를 공유하는 DES, RC4 같은 대칭키 암호화 알고리즘 으로 보안을 제공한다.
2. 서버와 클라이언트 상호 인증(ex. 공개키 암호 알고리즘, 전자서명 알고리즘, 공개키 인증서)이 이루어진다.
3. 메시지 인증 코드를 이용하여 메시지 무결성을 보장한다.

### SSL Handshake Protocol

![image](https://user-images.githubusercontent.com/37951612/78139027-d0fbc780-7462-11ea-8c1a-b346d39b716c.png)

인증서를 교환하여 서로를 인증하고, 공유키를 생성하여 암호화된 통신을 수행한다.

1. **Client** hello

    자신이 사용할 SSL의 버전, Cipher suite list, 클라이언트 난수를 생성하여 보낸다.

2. **Server** hello

    암호화 방법을 선택하고 서버 난수를 생성하여 보낸다.

3. **Server** Certificate

    클라이언트는 CA의 공개키로 인증서를 해독하여 **서버의 공개키** 를 획득한다.

    클라이언트는 클라이언트와 서버의 난수를 각각 사용하여 **Pre-Master Secret** 값을 생성하고, **서버의 공개키**로 암호화하여 서버에게 보낸다. **서버는 개인키**로 해당 암호문을 복호화한다.

    암호문의 복호화가 제대로 이루어지면, **서버**는 클라이언트에 **인증**을 마친다.

4. **Server** Key Exchange

    인증서가 없거나, 인증서가 서명용으로만 사용될 때 메시지를 보낸다

5. Certificate Request **(Server -> Client)**

    클라이언트에 인증서를 요구한다(암호 제품군에 따라 과정 자체 여부가 달라질 수 있다)

6. **Server** hello done

    서버가 클라이언트에게 보낼 메시지를 모두 보냈음

7. **Client** Certificate

    클라이언트의 인증서를 개인키로 암호화하고 클라이언트 인증서 공개 키를 사용하여 확인한다.

8. Certificate Verify **(Client -> Server)**

    클라이언트의 인증서를 서버가 쉽게 확인할 수 있도록 전자서명하고 서버에게 보낸다. 해당 메시지를 통해 서버는 클라이언트 인증서 공개 키가 유효한자 확인하고 **클라이언트 인증**을 마친다.

9.  **Client** Key Exchange

    PMS(Pre-Master Secret, 일종의 난수값), Client 난수, Server 난수를 이용하여 **암호화키**와 **메시지 인증 코드용 공유키**를 생성한다.

10. Change Cipher Spec **(Client -> Server)**

    이후에 전송되는 모든 메시지를 (서버와 협상된 알고리즘과 키를 이용하여) 암호화 시키겠다고 서버에 알린다. 직후, Finished 메시지를 생성하여 서버에 전송한다.

11. Finished **(Client <-> Server)**

    클라이언트와 SSL 서버 간 SSL 핸드쉐이크 종료
