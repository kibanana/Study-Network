## HTTP

## DNS (Domain Name System)
- 네트워크 상에서 컴퓨터들은 IP 주소로 서로를 구별하고 통신하는데, IP 주소를 사람이 기억하기 어렵기때문에 쉽게 기억할 수 있는 도메인 주소체계를 만들었다.

### DNS 체계

![image](https://user-images.githubusercontent.com/37951612/78102862-557c2500-7426-11ea-9441-5a9f1a2a8e24.png)

- 도메인 체계의 최상위는 루트(`root`)로, 인터넷 도메인의 시작점이다
- **루트**(`root`) **도메인**의 하위에 있는 것을 **1단계 도메인**, **최상위 도메인**이라고 한다.
- 최상위 도메인은 국가명을 나타내는 **국가 최상위 도메인**, 일반적으로 사용되는 **일반 최상위 도메인**으로 구분할 수 있다.

### Web의 정보 전달 흐름
1. 사용자가 브라우저의 주소창에 도메인을 입력 후 Enter
2. 사용자 PC의 HOST 파일 또는 이전에 저장된 DNS 캐싱 정보로 해당 도메인 연결 or 사용자 측의 네트워크를 제공하는 통신사/기관의 캐싱 DNS 서버에 질의
3. 최상위 Root 네임서버에서 하부 네임서버로 이동하며 네임서버를 찾으며, 해당 네임서버에서 정보를 검색하여 사용자에게 DNS 레코드의 캐싱정보가 전달되는 구조

### DNS Server

![image](https://user-images.githubusercontent.com/37951612/78103480-03d49a00-7428-11ea-9086-5d308984a00a.png)

![image](https://user-images.githubusercontent.com/37951612/78104075-72662780-7429-11ea-8541-092c1aa751b0.png)

접속하려는 사이트에 대한 정보를 가진 서버의 주소, 즉 IP 주소를 알아야 웹에 접속할 수 있다. 하지만 사이트의 수가 방대하다면 전세계적으로 **수많은 도메인에 연결된 IP를 알아내는 것은 힘들다.**  
이런 문제를 해결하기 위해 **DNS Server**가 생겼다.

DNS의 **NS(Name Server)** 는 **도메인에 연결된 서버의 IP를 찾아주는 역할**을 담당한다. 웹 브라우저와 서버 사이에 위치하며, `naver.com` 같은 주소 정보를 받아서 **해당 도메인이 연결된 NS로 접속하여 서버의 IP 주소를 요청**한다. NS는 `naver.com`의 IP 주소를 찾은 뒤 **브라우저에게 IP 주소를 응답**한다.

1. 클라이언트(브라우저)에서 `/etc/resolv.conf` 에 지정되있는 네임서버로 `www.yahoo.com`에 대한 요청을 전달한다.
2. **일반 네임서버** 는 루트네임서버의 IP주소를 기록한 'hint 파일'을 가지고 있는데 이것을 참조하여 **루트네임서버** 에 `www.yahoo.com`에 대한 요청을 전달한다. 루트네임서버는 **최상위네임서버들의 네임서버명(NS레코드)과 IP주소(A레코드)** 를 가지고 있는데 이를 **글루레코드(glue record)** 라고 한다. 이 글루레코드를 참조하여 `.com` **네임서버** 를 참조하라고 응답한다(**루트 네임서버는 전세계에 13개뿐**이다).
3. `.com` 네임서버에는 `.com` 을 **최상위도메인으로 사용하는 도메인들의 글루레코드** 를 가지고 있기에 이를 참조하여 `www.yahoo.com`의 **네임서버** 를 참조하라고 응답한다.
4. `yahoo.com` 의 네임서버는 `yahoo.com` 도메인에 대한 존(zone)파일을 참조하여 `www.yahoo.com` 의 **IP주소(A레코드)** 를 클라이언트가 **최초 요청을 한 네임서버로 되돌려 준다.**
5. 최초 요청을 받은 네임서버는 **클라이언트에게** `www.yahoo.com`의 **IP주소를 전송한다.**  

DNS서버는 한 번 검색한 결과는 메모리의 캐시에 기록하며, 같은 정보가 요청되면 캐시에 있는 정보를 전송한다. 이때, 캐시에는 유효기간(`TTL: Time To Live`)이 정해져 있으므로 유효기간이 지난 정보는 캐시에서 삭제된다.

### DNS 질의 방법
- **반복적 질의**

  ![image](https://user-images.githubusercontent.com/37951612/78107072-c3791a00-742f-11ea-9f67-e4bb9ff56b48.png)

  1. **로컬 DNS** 에게 요청: 로컬에 해당 정보가 없다면 루트 DNS 서버에 요청한다
  2. **루트 DNS** 는 자기는 모르고, 아마 최상위 DNS 서버(TLD)는 알 거라며 로컬 DNS에게 알려줌
  3. **로컬 DNS** 는 최상위 DNS 서버에 요청
  4. **최상위 DNS** 서버는 자기는 모르고, 책임 DNS 서버는 알 거라고 알려줌
  5. **로컬 DNS** 는 책임 DNS 서버에 요청
  6. **책임 DNS** 서버는 해당 요청을 처리할 수 있는 정보를 가지고 있기 때문에 대응하는 **IP 주소** 를 알려줌
  7. **로컬 DNS** 는 받아온 정보를 사용자에게 최종적으로 알려주고, 자신의 **DNS 레코드에 캐시를 저장** 한다

- **재귀적 질의**

  ![image](https://user-images.githubusercontent.com/37951612/78107075-c6740a80-742f-11ea-9620-d5dedc677f71.png)

  1. **로컬 DNS** 에게 요청: 로컬에 해당 정보가 없다면 루트 DNS 서버에 요청한다
  2. **루트 DNS** 서버는 자신이 모르니까 최상위 DNS 서버에 물어본다
  3. **최상위 DNS** 서버는 자신이 모르니까 책임 DNS 서버에 물어본다
  4. **책임 DNS** 서버는 요청 **IP 정보** 를 알고 있기 때문에 최상위 DNS에게 해당 정보를 알려준다
  5. **최상위 DNS** 는 받은 정보를 다시 루트 DNS에게 알려준다
  6. **루트 DNS** 는 로컬 DNS에게 받은 정보를 알려준다
  7. **로컬 DNS** 는 최종적으로 사용자에게 정보를 전달하고, 자신의 DNS 레코드에 캐시를 저장한다.

> 재귀적 질의는 말 그대로 재귀적으로 질의를 하는 것이고,  
  반복적 질의는 DNS 서버마다 로컬 DNS가 반복적으로 질문을 하는 방법을 말하는 것이다.

> 해당 질의가 재귀적 질의인지, 반복적 질의인지는 Wireshark로 DNS 프로토콜을 뜯어보면 알 수 있다.  
  Application Layer 정보 중 `Recursion desired`가 1이면 재귀적 질의, 0이면 반복적 질의다.

### DNS 레코드 타입

[주요 DNS 레코드 목록](https://www.codns.com/b/B05-172)

- **A (Address Mapping Records)**

  주어진 호스트에 대한 IP 주소를 알려주며, **정규화된 도메인 이름 / 호스트명을 해당 IP 주소로 변환**하는 데에 사용된다.

- **AAAA(IP Version 6 Address Records)**

  A 레코드와 같은 방식으로 작동하며, 주어진 **호스트에 대한 IPv6 주소**를 알려준다.

- **CNAME(Canonical Name)**

  **도메인 이름의 별칭**(A 레코드에 별명)을 만드는 데 사용된다. 도메인을 외부 도메인으로 별칭을 지정하려는 경우 유용하며, 경우에 따라 CNAME 레코드를 제거하고 A 레코드로 대체하면 성능 오버헤드를 줄일 수 있다.

- **HINFO(Host Information)**

  **호스트** 에 대한 일반 정보를 얻는데 사용되며 **CPU 및 OS 유형** 을 알려준다. 

  두 호스트가 통신하기를 원할때 운영체제 특정 프로토콜을 사용할 수 있는 가능성을 제공(보안상의 이유때문에 HINFO 레코드는 공용 서버에서 사용되지 않는다)

- **ISDN(Integrated Services Digital Network)**

  **호스트의 ISDN 주소** 를 알려준다. ISDN 레코드는 A 레코드의 변형 기능만 제공한다.

  ISDN 주소: 국가코드, 국가별 대상코드, ISDN 가입자 번호 및 선택적 ISDN 하위 주소로 구성된 전화번호

- **MX(Mail Exchanger)**

  **DNS 도메인 이름에 대한 메일 교환 서버(의 위치 정보 = IP 주소)** 를 알려준다. `SMTP(Simple Mail Transfer Protocol)`가 **전자 메일을 적절한 호스트로 라우팅하는데 사용** 된다. 일반적으로 DNS 도메인에 대해 둘 이상의 메일 교환 서버가 있으며 각 도메인에 우선 순위가 설정된다.

- **NS(Name Server)**

  주어진 호스트에 대한 **공식적인 NS(Name Server)**(해당 영역을 가진 서버 이름)를 알려준다.

- **SRV(SeRVice)**

  **특정유형의 (TCP/IP) 서비스를 제공하는 서버 위치 정보** 를 지정된 DNS호스트의 목록에 매핑

- **PTR(Reverse-Lookup Pointer Records)**

  정방향 DNS 확인(`A`, `AAAA` Record)과 달리 **IP 주소를 기반으로 도메인 네임을 찾는다** (**역방향**).

- **SOA(Start Of Authority)**

  권한 시작 레코드. DNS 영역에 대한 핵심 정보를 지정하며 기본 NS, 도메인 관리자의 전자메일, 도메인 일련번호 및 영역 새로고침과 관련된 여러 타이머를 포함하며 DNS 영역에 대한 핵심 정보를 지정한다.

  DNS Server 내에서 각 도메인 영역을 식별하는 레코드

- **TXT(Text)**

  형식이 지정되지 않은 임의의 텍스트 문자열을 저장할수 있다(파일도 가능). 일반적으로 `SPF(Sender Policy Framework)`가 (송신자를 위조한)가짜 메일을 막기 위해 사용한다.


## FTP (File Transfer Protocol)

파일 전송 프로토콜. 인터넷을 통해 한 컴퓨터에서 다른 컴퓨터로 파일을 전송할 수 있는 방법, 그를 지원하는 프로그램을 모두 일컫는다.

### 제어 및 File 전송

Client가 Server의 특정 Port에 서비스를 요청하면 Server가 이를 처리하고 Client에게 처리 결과를 제공하는 것과 달리, **FTP는 Client와 Server 사이에서 서비스 요청 및 결과 제공을 위한 명령(command) 포트(`21`), 실제로 파일을 전송하기 위한 데이터 전송(data) 포트(`20`)가 존재한다.**

> 네트워크 포트: 네트워크를 통해 데이터가 이동하는 통로

1. FTP Client는 `21`번 포트(FTP 명령 포트)를 통해 서버와 **Control Connection**을 설정
2. Client는 제어 연결을 통해 사용자 계정과 비밀번호를 전송한다.
3. Client는 제어 연결을 통해 원격지의 디렉터리 변경과 같은 명령을 전송한다.
4. Server는 제어 연결을 통해 파일 전송 명령을 받은 **TCP Data Connection**을 초기화한다.
5. 하나의 파일 전송을 끝내면 Data Connection을 Close 하고, 다음 파일 전송을 위해서는 새로운 TCP Connection을 생성해야 한다.

### Out of Band (<=> In band)
**파일을 전송하는 연결과 제어 연결을 다르게 하는 것.** `Active mode`, 21번 포트로 접속 제어(Client와 Server 접속이 끊길 때까지 유지된다), 20번 포트로 파일 전송하는 방식(파일을 주고 받을 때에만 유지된다)

### Passive mode
Active mode에서 Server가 Client에 접속을 시도하기 때문에 **Client 방화벽이 접근을 차단하면 FTP가 정상적으로 동작하지 않는다.** 이를 해결하기 위해 `Passive mode`를 사용한다.

20번 포트 대신 1024번 이후의 임의 포트를 이용한다. FTP Server와 Client 모두가 Passive mode를 지원해야 Passive mode로 동작할 수 있다.

1. FTP Client가 리눅스 서버 21(명령) 포트로 접속 요청을 한다
2. FTP Server는 데이터 통로를 위한 포트 3444를 임의로 하나 할당하고 포트 번호를 Client에게 알려준다
3. Client는 Destination Port를 선택하고 FTP Server가 알려준 포트(3444)에 대해 접속 요청을 한다
4. Server가 접속을 허용하고 파일을 주고받는다

### 익명(Anonymous) 계정
공개형 FTP는 공식적인 사용자 계정 및 암호 입력이 필요 없다. 따라서 하나의 공용 계정을 통해 모든 사용자가 간편하게 접속할 수 있다. 이를 익명 계정이라고 한다.  
통상적으로 Anonymous라는 계정에 자신의 이메일 주소를 암호로 입력하면, FTP Server에 접속하여 파일을 내려받을 수 있다(올리는 작업은 보안상 제한됨).

### 장단점

- 동작 방식이 단순, 직관적이므로 사용법도 간단하다
- WWW 방식보다 빠르게 파일을 한꺼번에 주고받을 수 있다

- 사진, 음악, 동영상 등의 멀티미디어 콘텐츠는 내려받기 완료 후 확인이 가능하다(WWW 환경에선 내려받으며 재생 가능)
- 기본적으로 명령어 기반의 통신 서비스라서 별도의 FTP Client 프로그램을 사용하지 않으면 어렵다

## Telnet
인터넷을 통해 원격지의 호스트 컴퓨터에 접속할 때 지원되는 인터넷 표준 프로토콜

일종의 터미널 애뮬레이션 프로토콜로, `NVT(Network Virtual Terminal`, 원격지 시스템과 로컬 시스템이 달라도 원활한 통신을 위해 데이터를 변환시켜주는 가상장치)이라는 가상터미널 개념을 사용한다. 터미널과 호스트는 1:1 대칭 관계다.


## NFS (Network File System)


## DHCP (Dynamic Host Configuration Protocol)
인터넷을 사용할 때 이용하는 인터넷 주소는 IP이며, 이 IP 주소는 한정적이기 때문에 무한한 자원이 아니다. 따라서 **현재 통신을 하지 않는 PC로부터 IP를 회수하고 IP를 요청하는 PC에 현재 사용할 수 있는 IP를 동적으로 할당**해준다.

![image](https://user-images.githubusercontent.com/37951612/78268464-2dceaf00-7543-11ea-8264-c90f7484f403.png)

## SMTP (Simple Mail Transfer Protocol) & POP3 (Post Office Protocol 3)
**SMTP 서버는 메일 서비스를 제공하는 서버**다. **메일을 수신하는 서버는 POP3 서버**다.

### 메일 전송 과정
1. 메일을 송신하는 소프트웨어에서 SMTP로 메일을 보낸다
2. SMTP 서버는 `@` 뒤의 도메인 주소에 매핑되는 IP 주소를 찾는다
3. 찾은 IP 주소에 메일 데이터를 전송한다
4. 메일 데이터를 받은 POP3 서버는 `@` 앞의 유저명을 찾아서 해당 유저의 메일함에 데이터를 저장한다

### SMTP 보안
SMTP는 따로 인증 기능이 없기 때문에 다른 사용자로 위장하여 메일을 보낼(공격) 수도 있다.

- SMTP AUTH

  메일을 송신하기 전 SMTP 서버의 사용자 ID, PWD로 인증한다

- POP Before SMTP

  메일을 수신하기 전 POP3 서버의 사용자 ID, PWD로 인증한다
